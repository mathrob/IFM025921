<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IFM025921</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
    <link rel="stylesheet" href="../style.css" />
</head>

<body>
    <header>
        <h1 style="color: white">Module 9 - Note de cours</h1>
    </header>
    <div class="container">
        <a href="../index.html" class="back-link">‚Üê Retour au module principal</a>

        <section id="module-9-1" class="module-section">
            <h1 id="menus-contextuels">Menus contextuels en SwiftUI</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/FlpY3t8hLPk" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <h2>Qu‚Äôest-ce qu‚Äôun menu contextuel en SwiftUI ?</h2>
            <p>
                Un menu contextuel est un menu d‚Äôoptions qui s‚Äôaffiche lorsqu‚Äôun utilisateur effectue un appui long sur
                une vue.
            </p>

            <h4>üéØ Exemple d‚Äôutilisation :</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Modifier les couleurs d‚Äôun texte.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Offrir des actions comme copier, supprimer, partager.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Afficher des options de personnalisation sur un √©l√©ment de liste ou
                    une image.</li>
            </ul>

            <p>üëâ SwiftUI permet d‚Äôajouter un menu contextuel √† n‚Äôimporte quelle vue en utilisant le modificateur
                <strong>.contextMenu {}</strong>.
            </p>

            <h2>Cr√©ation d‚Äôun menu contextuel simple</h2>

            <h4>Exemple : Changer les couleurs d‚Äôun texte via un menu contextuel</h4>
            <pre><code class="swift">import SwiftUI

struct ContentView: View {
    @State private var foregroundColor: Color = .black
    @State private var backgroundColor: Color = .white

    var body: some View {
        Text("Hello, world!")
            .font(.largeTitle)
            .padding()
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .contextMenu {
                Button(action: {
                    self.foregroundColor = .black
                    self.backgroundColor = .white
                }) {
                    Label("Couleurs normales", systemImage: "paintbrush")
                }

                Button(action: {
                    self.foregroundColor = .white
                    self.backgroundColor = .black
                }) {
                    Label("Couleurs invers√©es", systemImage: "paintbrush.fill")
                }
            }
    }
}
</code></pre>

            <p><strong>contextMenu {}</strong> : Ajoute un menu qui s‚Äôaffiche au clic long sur le Text.</p>
            <p><strong>Boutons du menu</strong> :</p>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ ‚ÄúCouleurs normales‚Äù : Noir sur fond blanc.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ ‚ÄúCouleurs invers√©es‚Äù : Blanc sur fond noir.</li>
            </ul>
            <p><strong>Utilisation de Label("Texte", systemImage: "icone")</strong> : Pour ajouter une ic√¥ne au bouton.
            </p>

            <h4>üîé Comment tester ?</h4>
            <ol>
                <li>Ex√©cutez l‚Äôapplication.</li>
                <li>Faites un appui long sur le texte ‚ÄúHello, world!‚Äù.</li>
                <li>Un menu s‚Äôaffiche avec les options de changement de couleur.</li>
            </ol>

            <h2>Ajouter des options avanc√©es au menu</h2>

            <p>On peut ajouter plus d‚Äôoptions et organiser les actions en groupes distincts.</p>

            <h4>Exemple : Ajouter des tailles de police et une option de r√©initialisation</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var foregroundColor: Color = .black
    @State private var backgroundColor: Color = .white
    @State private var fontSize: CGFloat = 24

    var body: some View {
        Text("Hello, world!")
            .font(.system(size: fontSize))
            .padding()
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .contextMenu {
                Section {
                    Button(action: { fontSize = 16 }) {
                        Label("Petite police", systemImage: "textformat.size")
                    }
                    Button(action: { fontSize = 32 }) {
                        Label("Grande police", systemImage: "textformat.size")
                    }
                }
                
                Section {
                    Button(action: {
                        foregroundColor = .black
                        backgroundColor = .white
                        fontSize = 24
                    }) {
                        Label("R√©initialiser", systemImage: "arrow.counterclockwise")
                    }
                }
            }
    }
}
</code></pre>

            <h4>Nouveaut√©s dans cet exemple :</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Ajout d‚Äôune section pour changer la taille de la police.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Ajout d‚Äôun bouton ‚ÄúR√©initialiser‚Äù pour remettre les valeurs par
                    d√©faut.</li>
            </ul>

            <h4>üîé Comment tester ?</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Appui long sur le texte ‚Üí un menu contextuel avec deux sections
                    appara√Æt.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ La premi√®re section permet de changer la taille du texte.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ La deuxi√®me section propose une option de r√©initialisation.</li>
            </ul>

            <h2>Ajouter un menu contextuel √† une liste d‚Äô√©l√©ments</h2>
            <p>On peut aussi ajouter un menu contextuel sur chaque √©l√©ment d‚Äôune liste.</p>

            <h4>Exemple : Menu contextuel sur une liste de contacts</h4>
            <pre><code class="swift">struct ContentView: View {
    let contacts = ["Alice", "Bob", "Charlie", "David"]

    var body: some View {
        List(contacts, id: \.self) { contact in
            Text(contact)
                .contextMenu {
                    Button(action: {
                        print("Envoyer un message √† \(contact)")
                    }) {
                        Label("Envoyer un message", systemImage: "message")
                    }
                    
                    Button(action: {
                        print("Appeler \(contact)")
                    }) {
                        Label("Appeler", systemImage: "phone")
                    }
                }
        }
    }
}
</code></pre>
            <h4>Nouveaut√©s dans cet exemple :</h4>
            <ul>
                <li style="margin-left: 30px;">Chaque √©l√©ment de la liste a son propre menu contextuel.</li>
                <li style="margin-left: 30px;">
                    Le menu propose deux actions :
                    <ul>
                        <li style="margin-left: 30px;"> ‚Ä¢ Envoyer un message</li>
                        <li style="margin-left: 30px;"> ‚Ä¢ Passer un appel </li>
                    </ul>
                </li>
                <li style="margin-left: 30px;">Lorsqu‚Äôune option est s√©lectionn√©e, elle affiche un message dans la
                    console.</li>
            </ul>

            <h4>üîé Comment tester ?</h4>
            <ol>
                <li>Lancez l‚Äôapplication et faites un appui long sur un contact.</li>
                <li>Le menu affiche les options d‚Äôappel et de message.</li>
            </ol>

            <h2>Ajouter une image avec un menu contextuel</h2>
            <p>On peut √©galement ajouter un menu contextuel sur une image, ce qui est utile pour des applications de
                galerie ou de r√©seaux sociaux.</p>

            <h4>Exemple : Menu contextuel pour interagir avec une image</h4>
            <pre><code class="swift">struct ContentView: View {
    var body: some View {
        Image(systemName: "photo")
            .resizable()
            .frame(width: 100, height: 100)
            .foregroundColor(.blue)
            .contextMenu {
                Button(action: {
                    print("Partager la photo")
                }) {
                    Label("Partager", systemImage: "square.and.arrow.up")
                }
                
                Button(action: {
                    print("Supprimer la photo")
                }) {
                    Label("Supprimer", systemImage: "trash")
                }
            }
    }
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li style="margin-left: 30px;">L‚Äôimage est interactive : un appui long ouvre un menu.</li>
                <li style="margin-left: 30px;">Le menu offre deux actions :
                    <ul>
                        <li style="margin-left: 30px;"> ‚Ä¢ Partager la photo üì§.</li>
                        <li style="margin-left: 30px;"> ‚Ä¢ Supprimer la photo üóëÔ∏è.</li>
                    </ul>
                </li>
            </ul>

            <h2>R√©sum√© des concepts abord√©s</h2>
            <ul>
                <li>‚úÖ Un menu contextuel (contextMenu {}) s‚Äôaffiche lors d‚Äôun appui long.</li>
                <li>‚úÖ On peut l‚Äôajouter √† n‚Äôimporte quelle vue (Text, Image, List).</li>
                <li>‚úÖ Chaque menu peut contenir des boutons, du texte et des ic√¥nes.</li>
                <li>‚úÖ On peut organiser les actions en plusieurs Section pour plus de clart√©.</li>
            </ul>
        </section>

        <section id="module-9-2" class="module-section">
            <h1 id="dessin">Dessin en 2D avec SwiftUI üé®</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/R7OjaTKrUbw" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <p>
                SwiftUI propose des outils puissants pour dessiner des formes, personnaliser leur apparence et cr√©er des
                trac√©s sur mesure.
            </p>

            <h4>üõ† Pourquoi apprendre le dessin 2D en SwiftUI ?</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Ajouter des √©l√©ments graphiques interactifs (boutons stylis√©s,
                    indicateurs de progression).</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Personnaliser l‚Äôinterface avec des formes uniques.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Cr√©er des animations et des transitions fluides.</li>
            </ul>

            <h2>Dessiner des formes de base</h2>
            <p>SwiftUI propose cinq formes pr√©d√©finies que l‚Äôon peut directement utiliser :</p>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Rectangle()</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Circle()</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Capsule()</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Ellipse()</li>
                <li style="margin-left: 30px;"> ‚Ä¢ RoundedRectangle(cornerRadius:)</li>
            </ul>

            <h4>Exemple : Afficher un cercle rouge de 200 x 200 pixels</h4>
            <pre><code class="swift">Circle()
    .fill(.red)
    .frame(width: 200, height: 200)
</code></pre>
            <p><strong>.fill(.red)</strong> : Remplit le cercle en rouge.</p>
            <p><strong>.frame(width: 200, height: 200)</strong> : D√©finit la taille du cercle.</p>

            <br />

            <h4>Exemple : Ajouter une bordure bleue √† une capsule</h4>
            <pre><code class="swift">Capsule()
    .stroke(lineWidth: 10)
    .foregroundColor(.blue)
    .frame(width: 200, height: 100)
</code></pre>
            <p><strong>.stroke(lineWidth: 10)</strong> : Dessine uniquement les contours de la forme.</p>
            <p><strong>.foregroundColor(.blue)</strong> : D√©finit la couleur de la bordure.</p>

            <br />

            <h4>Exemple : Cr√©er un rectangle arrondi avec un contour en pointill√©s</h4>
            <pre><code class="swift">RoundedRectangle(cornerRadius: 20)
    .stroke(style: StrokeStyle(lineWidth: 8, dash: [10]))
    .foregroundColor(.blue)
    .frame(width: 200, height: 100)
</code></pre>
            <p><strong>.stroke(style: StrokeStyle(lineWidth: 8, dash: [10]))</strong> : dash: [10] cr√©e un effet de
                pointill√©s (10 points de trait, 10 points d‚Äôespace).</p>


            <h2>Ajouter une superposition (overlay)</h2>
            <p>Si l‚Äôon souhaite combiner un fond et une bordure, on peut superposer (overlay) une forme sur elle-m√™me.
            </p>

            <h4>Exemple : Un ovale rouge avec un contour bleu</h4>
            <pre><code class="swift">Ellipse()
    .fill(.red)
    .overlay(
        Ellipse()
            .stroke(.blue, lineWidth: 10)
    )
    .frame(width: 250, height: 150)
</code></pre>
            <p><strong>.overlay()</strong> superpose une deuxi√®me ellipse au-dessus de la premi√®re.</p>

            <h2>Dessiner un trac√©</h2>
            <p>Un Path permet de cr√©er des formes personnalis√©es en d√©finissant des points et en reliant ces points avec
                des lignes ou des courbes.</p>

            <h4>Exemple : Dessiner un triangle</h4>
            <pre><code class="swift">struct ContentView: View {
    var body: some View {
        Path { path in
            path.move(to: CGPoint(x: 10, y: 0))
            path.addLine(to: CGPoint(x: 10, y: 350))
            path.addLine(to: CGPoint(x: 300, y: 300))
            path.closeSubpath()
        }
        .stroke(Color.blue, lineWidth: 5)
    }
}
</code></pre>
            <p><strong>move(to:)</strong> : Place le point de d√©part.</p>
            <p><strong>addLine(to:)</strong> : Ajoute une ligne reliant deux points.</p>
            <p><strong>closeSubpath()</strong> : Ferme la forme pour cr√©er un triangle.</p>

            <h2>Cr√©er une forme personnalis√©e</h2>
            <p>Les formes pr√©d√©finies sont utiles, mais parfois nous avons besoin de formes plus complexes.</p>
            <p>Pour cela, nous cr√©ons une structure qui respecte le protocole Shape.</p>

            <h4>Exemple : Cr√©er une forme personnalis√©e avec une courbe</h4>
            <pre><code class="swift">struct MyShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()

        path.move(to: CGPoint(x: rect.minX, y: rect.minY))
        path.addQuadCurve(
            to: CGPoint(x: rect.minX, y: rect.maxY),
            control: CGPoint(x: rect.midX, y: rect.midY)
        )
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.closeSubpath()

        return path
    }
}
</code></pre>

            <h4>Utilisation de la forme :</h4>
            <pre><code class="swift">MyShape()
    .fill(.red)
    .frame(width: 360, height: 350)
</code></pre>
            <p>Les formes personnalis√©es sont r√©utilisables et supportent les modificateurs comme .fill(), .stroke(),
                etc.</p>

            <h2>Ajouter des d√©grad√©s de couleur</h2>
            <h4>SwiftUI propose trois types de d√©grad√©s :</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Lin√©al (LinearGradient)</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Radial (RadialGradient)</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Angulaire (AngularGradient)</li>
            </ul>

            <h4>Exemple : Un cercle avec un d√©grad√© radial</h4>
            <pre><code class="swift">struct ContentView: View {
    let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple])
    
    var body: some View {
        Circle()
            .fill(RadialGradient(gradient: colors, center: .center, startRadius: 0, endRadius: 300))
            .frame(width: 200, height: 200)
    }
}
</code></pre>
            <p>Le centre du cercle est rouge et devient violet sur les bords.</p>
        </section>

        <section id="module-9-3" class="module-section">
            <h1 id="animations">Animations et transitions en SwiftUI üé¨‚ú®</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/guk9GNDavFY" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <p>SwiftUI facilite l‚Äôanimation des vues gr√¢ce √† un syst√®me de gestion fluide et performant des animations.
            </p>

            <h4>üõ† Pourquoi utiliser des animations ?</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Am√©liorer l‚Äôexp√©rience utilisateur avec des transitions fluides.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Attirer l‚Äôattention sur des √©l√©ments interactifs.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Rendre une interface plus engageante (ex. boutons anim√©s, transitions
                    visuelles).</li>
            </ul>

            <h2>Animation implicite (.animation())</h2>
            <p>Les animations implicites permettent d‚Äôanimer les modifications d‚Äôun √©tat en ajoutant .animation() √† un
                modificateur.</p>

            <h2>Exemple : Rotation anim√©e d‚Äôun bouton</h2>
            <pre><code class="swift">import SwiftUI

struct ContentView: View {
    @State private var rotation: Double = 0

    var body: some View {
        Button(action: {
            self.rotation = (self.rotation < 360 ? self.rotation + 60 : 0)
        }) {
            Text("Cliquez pour tourner")
                .rotationEffect(.degrees(rotation))
                .animation(.linear(duration: 1), value: rotation)
        }
    }
}
</code></pre>
            <p>√Ä chaque clic, le texte tourne de 60 degr√©s.</p>
            <p>.animation(.linear(duration: 1), value: rotation) ajoute une transition fluide sur 1 seconde.</p>

            <h2>Animation avec plusieurs propri√©t√©s</h2>
            <p>On peut animer plusieurs propri√©t√©s en m√™me temps, comme la rotation et l‚Äô√©chelle.</p>

            <h2>Exemple : Un bouton qui tourne et grandit progressivement</h2>
            <pre><code class="swift">struct ContentView: View {
    @State private var rotation: Double = 0
    @State private var scale: CGFloat = 1

    var body: some View {
        Button(action: {
            self.rotation = (self.rotation < 360 ? self.rotation + 60 : 0)
            self.scale = (self.scale < 2.8 ? self.scale + 0.3 : 1)
        }) {
            Text("Cliquez pour animer")
                .scaleEffect(scale)
                .rotationEffect(.degrees(rotation))
                .animation(.linear(duration: 1), value: rotation)
        }
    }
}
</code></pre>
            <p>Le bouton tourne ET grandit √† chaque clic.</p>

            <h2>Utiliser une animation avec effet de rebond (spring())</h2>
            <p>L‚Äôanimation spring() ajoute un effet de rebond naturel.</p>

            <h2>Exemple : Un bouton qui rebondit l√©g√®rement</h2>
            <pre><code class="swift">Text("Cliquez pour animer")
    .scaleEffect(scale)
    .rotationEffect(.degrees(rotation))
    .animation(.spring(response: 1, dampingFraction: 0.2, blendDuration: 0), value: rotation)
</code></pre>
            <p>spring(response: 1, dampingFraction: 0.2) exag√®re le mouvement et rebondit l√©g√®rement avant de s‚Äôarr√™ter.
            </p>

            <h2>R√©p√©ter une animation</h2>
            <p>L‚Äôanimation peut se r√©p√©ter plusieurs fois avec .repeatCount() ou √† l‚Äôinfini avec .repeatForever().</p>

            <h4>Exemple : R√©p√©ter une animation 10 fois</h4>
            <pre><code class="swift">.animation(.linear(duration: 1).repeatCount(10), value: rotation)
</code></pre>

            <h4>Exemple : R√©p√©ter une animation en boucle infinie</h4>
            <pre><code class="swift">.animation(.linear(duration: 1).repeatForever(autoreverses: true), value: rotation)
</code></pre>
            <p>autoreverses: true alterne entre les √©tats (va-retour fluide).</p>

            <h2>Animation explicite (withAnimation {})</h2>
            <p>L‚Äôanimation explicite permet de contr√¥ler pr√©cis√©ment quelles propri√©t√©s doivent √™tre anim√©es.</p>

            <h4>Exemple : Animer une rotation mais pas le changement de taille</h4>
            <pre><code class="swift">Button(action: { 
    withAnimation(.linear(duration: 2)) {
        self.rotation = (self.rotation < 360 ? self.rotation + 60 : 0)
    }
    self.scale = (self.scale < 2.8 ? self.scale + 0.3 : 1)
}) {
    Text("Cliquez pour animer")
        .rotationEffect(.degrees(rotation))
        .scaleEffect(scale)
}
</code></pre>
            <p>Seule la rotation est anim√©e, le changement d‚Äô√©chelle est instantan√©.</p>

            <h2>Animation au chargement d‚Äôune vue (onAppear())</h2>
            <p>On peut animer une vue d√®s son apparition avec onAppear().</p>

            <h4>Exemple : Faire tourner une ic√¥ne d√®s l‚Äôaffichage</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var rotation: Double = 0

    var body: some View {
        Image(systemName: "forward.fill")
            .rotationEffect(.degrees(rotation))
            .onAppear {
                withAnimation(Animation.linear(duration: 5).repeatForever(autoreverses: false)) {
                    rotation = 360
                }
            }
    }
}
</code></pre>
            <p>L‚Äôic√¥ne tourne ind√©finiment d√®s que la vue est affich√©e.</p>

            <h2>Ajout de transitions anim√©es (.transition())</h2>
            <p>Les transitions animent l‚Äôapparition et la disparition des vues.</p>

            <h4>Exemple : Faire appara√Ætre un texte avec un effet de fondu</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var isVisible: Bool = false

    var body: some View {
        VStack {
            Toggle("Afficher le texte", isOn: $isVisible.animation(.easeInOut(duration: 1)))
                .padding()

            if isVisible {
                Text("Hello, world!")
                    .font(.largeTitle)
                    .transition(.opacity)
            }
        }
    }
}
</code></pre>
            <p>Le texte appara√Æt et dispara√Æt en fondu lorsqu‚Äôon active/d√©sactive le toggle.</p>

            <h2>Types de transitions disponibles</h2>
            <table border="1" style="border-collapse: collapse;">
                <thead>
                    <tr>
                        <th>Transition</th>
                        <th>Effet</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 4px;">.opacity</td>
                        <td style="padding: 4px;">Fondu en entr√©e/sortie.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.scale</td>
                        <td style="padding: 4px;">Agrandissement/r√©duction.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.slide</td>
                        <td style="padding: 4px;">D√©placement vers l‚Äôint√©rieur/l‚Äôext√©rieur.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.move(edge: .leading)</td>
                        <td style="padding: 4px;">Arriv√©e par la gauche.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.asymmetric(insertion: .scale, removal: .slide)</td>
                        <td style="padding: 4px;">Effet diff√©rent √† l‚Äôapparition et √† la disparition.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Exemple : Une transition qui combine opacity et slide</h4>
            <pre><code class="swift">.transition(AnyTransition.opacity.combined(with: .slide))
</code></pre>
            <p>Le texte glisse tout en apparaissant progressivement.</p>
        </section>

        <section id="module-9-4" class="module-section">
            <h1 id="interactions">Gestes et interactions tactiles (Gesture Recognizers) en SwiftUI üëÜüì±</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/4KDPQ8cHnrs" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <p>SwiftUI permet de g√©rer facilement les interactions tactiles gr√¢ce aux gestures (reconnaisseurs de
                gestes). Ces gestes permettent aux utilisateurs d‚Äôinteragir avec l‚Äôinterface via :</p>
            <ul>
                <li style="margin-left: 30px;">Taps (toucher simple, double tap, long press)</li>
                <li style="margin-left: 30px;">Drags (glissement d‚Äôun √©l√©ment)</li>
                <li style="margin-left: 30px;">Pinch (zoom avec deux doigts)</li>
                <li style="margin-left: 30px;">Rotation (rotation avec deux doigts)</li>
                <li style="margin-left: 30px;">Combinaison de gestes</li>
            </ul>

            <h2>Ajout d‚Äôun simple tap (.onTapGesture)</h2>
            <p>Le geste le plus basique en SwiftUI est l‚Äôappui simple (TapGesture). Il est utile pour d√©clencher une
                action en touchant un √©l√©ment.</p>

            <h4>Exemple : Changer la couleur d‚Äôun cercle avec un tap</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var isRed = false

    var body: some View {
        Circle()
            .fill(isRed ? .red : .blue)
            .frame(width: 150, height: 150)
            .onTapGesture {
                isRed.toggle()
            }
    }
}
</code></pre>
            <p>√Ä chaque tap, la couleur alterne entre rouge et bleu.</p>

            <h2>G√©rer un double tap (.onTapGesture(count:))</h2>
            <p>On peut diff√©rencier un tap simple et un double tap en pr√©cisant count:.</p>

            <h4>Exemple : Changer la taille d‚Äôun cercle avec un double tap</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var size: CGFloat = 100

    var body: some View {
        Circle()
            .frame(width: size, height: size)
            .onTapGesture(count: 2) {
                size = (size == 100 ? 200 : 100)
            }
    }
}
</code></pre>
            <p>Un double tap agrandit ou r√©duit le cercle.</p>

            <h2>G√©rer un appui long (.onLongPressGesture)</h2>
            <pre><code class="swift">struct ContentView: View {
    @State private var isLiked = false

    var body: some View {
        Image(systemName: isLiked ? "heart.fill" : "heart")
            .resizable()
            .frame(width: 100, height: 100)
            .foregroundColor(.red)
            .onLongPressGesture {
                isLiked.toggle()
            }
    }
}
</code></pre>
            <p>Un appui long active ou d√©sactive l‚Äôic√¥ne de ‚Äúlike‚Äù.</p>

            <h2>D√©tecter un glissement (DragGesture)</h2>
            <p>Un glissement (DragGesture) est souvent utilis√© pour d√©placer un √©l√©ment √† l‚Äô√©cran.</p>

            <h4>Exemple : Faire glisser un carr√©</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var offset = CGSize.zero

    var body: some View {
        Rectangle()
            .fill(.blue)
            .frame(width: 100, height: 100)
            .offset(offset)
            .gesture(
                DragGesture()
                    .onChanged { gesture in
                        offset = gesture.translation
                    }
                    .onEnded { _ in
                        offset = .zero
                    }
            )
    }
}
</code></pre>
            <p>Le carr√© suit le doigt lors du drag et revient √† sa position initiale apr√®s le rel√¢chement.</p>

            <h2>D√©tecter une rotation (RotationGesture)</h2>
            <p>Le geste de rotation est souvent utilis√© pour faire pivoter un √©l√©ment.</p>

            <h4>Exemple : Faire tourner une image avec deux doigts</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var rotation: Angle = .zero

    var body: some View {
        Image(systemName: "arrow.triangle.2.circlepath")
            .resizable()
            .frame(width: 150, height: 150)
            .rotationEffect(rotation)
            .gesture(
                RotationGesture()
                    .onChanged { angle in
                        rotation = angle
                    }
            )
    }
}
</code></pre>
            <p>L‚Äôimage tourne en fonction du mouvement des doigts.</p>

            <h2>Zoom avec un pincement (MagnificationGesture)</h2>
            <p>Le geste de pincement (pinch) permet de zoomer ou d√©zoomer un √©l√©ment.</p>

            <h4>Exemple : Agrandir une image avec deux doigts</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var scale: CGFloat = 1.0

    var body: some View {
        Image(systemName: "photo")
            .resizable()
            .frame(width: 150, height: 150)
            .scaleEffect(scale)
            .gesture(
                MagnificationGesture()
                    .onChanged { value in
                        scale = value
                    }
            )
    }
}
</code></pre>
            <p>L‚Äôimage grandit lorsqu‚Äôon l‚Äô√©carte avec deux doigts et se r√©duit lorsqu‚Äôon pince.</p>

            <h2>Combiner plusieurs gestes (SimultaneousGesture)</h2>
            <p>On peut combiner plusieurs gestes, par exemple un glissement + une rotation.</p>

            <h4>Exemple : Glisser ET tourner un carr√©</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var offset = CGSize.zero
    @State private var rotation: Angle = .zero

    var body: some View {
        Rectangle()
            .fill(.green)
            .frame(width: 100, height: 100)
            .offset(offset)
            .rotationEffect(rotation)
            .gesture(
                SimultaneousGesture(
                    DragGesture()
                        .onChanged { gesture in
                            offset = gesture.translation
                        },
                    RotationGesture()
                        .onChanged { angle in
                            rotation = angle
                        }
                )
            )
    }
}
</code></pre>
            <p>Le carr√© peut √™tre d√©plac√© ET tourn√© en m√™me temps.</p>

            <h2>Diff√©rencier plusieurs gestes (ExclusiveGesture)</h2>
            <p>ExclusiveGesture permet de choisir quel geste a priorit√© si plusieurs sont d√©tect√©s.</p>

            <h4>Exemple : Un simple tap et un appui long sur le m√™me √©l√©ment</h4>
            <pre><code class="swift">struct ContentView: View {
    @State private var message = "Tap ou Long Press"

    var body: some View {
        Text(message)
            .padding()
            .gesture(
                ExclusiveGesture(
                    TapGesture()
                        .onEnded { _ in message = "Tap d√©tect√© !" },
                    LongPressGesture()
                        .onEnded { _ in message = "Appui long d√©tect√© !" }
                )
            )
    }
}
</code></pre>
            <p>Si l‚Äôutilisateur appuie longtemps, le tap est ignor√©.</p>

            <h2>R√©sum√© des gestes en SwiftUI</h2>
            <table border="1" style="border-collapse: collapse;">
                <thead>
                    <tr>
                        <th>Geste</th>
                        <th>Fonction</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 4px;">.onTapGesture()</td>
                        <td style="padding: 4px;">D√©tecte un tap.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.onTapGesture(count: 2)</td>
                        <td style="padding: 4px;">D√©tecte un double tap.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.onLongPressGesture()</td>
                        <td style="padding: 4px;">D√©tecte un appui long.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">DragGesture()</td>
                        <td style="padding: 4px;">D√©tecte un glissement.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">RotationGesture()</td>
                        <td style="padding: 4px;">D√©tecte une rotation avec deux doigts.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">MagnificationGesture()</td>
                        <td style="padding: 4px;">D√©tecte un pincement pour zoomer.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">SimultaneousGesture()</td>
                        <td style="padding: 4px;">Permet d‚Äôeffectuer deux gestes en m√™me temps.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">ExclusiveGesture()</td>
                        <td style="padding: 4px;">Donne la priorit√© √† un seul geste parmi plusieurs.</td>
                    </tr>
                </tbody>
            </table>
        </section>
    </div> style="margin-left: 30px;"
</body>
</section>
</div>

<footer class="footer">
    <p>D√©velopp√© par <a href="https://github.com/mathrob" style="color: white; text-decoration: underline;">Mathieu
            Robson</a> &copy; <span id="current-year"></span></p>
    <script>
        document.getElementById("current-year").textContent =
            new Date().getFullYear();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</footer>
<div class="back-to-top" id="back-to-top">‚Üë</div>
<script>
    const backToTopButton = document.getElementById("back-to-top");

    window.addEventListener("scroll", () => {
        if (window.scrollY > 300) {
            backToTopButton.style.display = "block";
        } else {
            backToTopButton.style.display = "none";
        }
    });

    backToTopButton.addEventListener("click", () => {
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    });
</script>
</body>

</html>