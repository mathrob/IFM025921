<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IFM025921</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
  <link rel="stylesheet" href="../style.css" />
</head>

<body>
  <header>
    <h1 style="color: white">Module 2 - Note de cours</h1>
  </header>
  <div class="container">
    <a href="../index.html" class="back-link">‚Üê Retour au module principal</a>

    <section id="module-2-playground" class="module-section">
      <h1 id="playground">Playground</h1>
      <p>
        Le playground est un outil de d√©veloppement int√©gr√© √† Xcode qui permet
        d'√©crire du code Swift et de voir les r√©sultats en temps r√©el. Il est
        tr√®s utile pour tester des algorithmes ou des id√©es rapidement.
      </p>

      <h2>Cr√©er un projet playground</h2>
      <p>
        Pour ouvrir un playground, il suffit de cliquer sur "File" dans la
        barre de menu, puis "New" et enfin "Playground". Il est possible de
        choisir entre un playground vide ou un playground interactif.
      </p>

      <h3>Vid√©o d√©monstrative</h3>
      <iframe width="1120" height="630" src="https://www.youtube.com/embed/aThQcPfztws" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen></iframe>

      <h3>Utilisation du playground</h3>
      <iframe width="1120" height="630" src="https://www.youtube.com/embed/VIAMZVHmTAA" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen></iframe>
    </section>

    <section id="module-2" class="module-section">
      <h1 id="swift-1">Introduction au langage Swift (Partie 1)</h1>

      <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language" target="_blank"
        style="color: red; font-size: large; text-decoration: underline;">R√©f√©rence officielle</a>

      <p>
        Swift est un langage de programmation moderne, d√©velopp√© par Apple et
        pr√©sent√© en 2014 lors de la WWDC (Worldwide Developers Conference).
        Cr√©√© pour remplacer Objective-C, il est puissant, facile √† apprendre
        et inspir√© de nombreux langages comme Python, Ruby et Rust. Swift est
        open source, ce qui le rend accessible √† tous, et constitue la base
        id√©ale pour d√©velopper des applications dans l‚Äô√©cosyst√®me Apple.
      </p>

      <h2 id="commentaires">Les commentaires</h2>
      <p>Swift propose trois types de commentaires :</p>
      <ul>
        <li>
          <code>//</code> : Un commentaire classique pour des annotations
          simples (aucun support de formatage).
        </li>
        <li>
          <code>//:</code> : Un commentaire supportant le markup, souvent
          utilis√© pour documenter le code dans Xcode.
        </li>
        <li>
          <code>/* */</code> : Un commentaire multiligne pour des annotations
          plus longues.
        </li>
      </ul>

      <pre><code class="language-swift">
    // Ceci est un commentaire classique
    
    //: Ceci est un commentaire Swift supportant le markup
    
    /* Ceci 
            est un 
                    commentaire 
                                multiligne */
  </code></pre>

      <h2 id="variables-constantes-types">Variables, constantes et types</h2>
      <p>
        Swift peut inf√©rer automatiquement le type des variables et des
        constantes, mais il est √©galement possible de l‚Äôindiquer explicitement
        :
      </p>
      <ul>
        <li>
          <strong>Inf√©rence :</strong> Le type est d√©termin√© en fonction de la
          valeur attribu√©e.
        </li>
        <li>
          <strong>Annotation :</strong> Le type est d√©fini explicitement avec
          "<strong>:</strong>"
        </li>
      </ul>
      <pre><code class="language-swift">
    // Variable
    var nombre = 10       // Inf√©rence : Swift d√©duit que 'nombre' est un Int
    var autreNombre: Int  // Annotation explicite
    autreNombre = 20

    // Constante
    let constante = 30    // Inf√©rence : Swift d√©duit que 'constante' est un Int
    let autreConstante: Int = 40 // Annotation explicite

    autreConstante = 50 // Erreur : impossible de modifier une constante
  </code></pre>

      <p>
        Vous pouvez d√©clarer plusieurs constantes ou variables sur une seule
        ligne, en les s√©parant par des virgules
      </p>
      <pre><code class="language-swift">
    var x = 0.0, y = 0.0, z = 0.0
    let x = 0.0, y = 0.0, z = 0.0
  </code></pre>

      <p>
        Les noms de variables et de constantes peuvent contenir presque tous
        les caract√®res, y compris les caract√®res Unicode :
      </p>
      <pre><code class="language-swift">
    let œÄ = 3.14159
    let ‰Ω†Â•Ω = "‰Ω†Â•Ω‰∏ñÁïå"
    let üê∂üêÆ = "dogcow"
    let b√©b√© = "üë∂üèΩ"
  </code></pre>

      <h2 id="interpolation">L'interpolation</h2>
      <p>
        L'interpolation permet d'ins√©rer des variables ou des constantes dans
        une cha√Æne de caract√®res :
      </p>
      <pre><code class="language-swift">
    let prenom = "Mathieu"
    let age = 20
    var message = "Bonjour, je m'appelle \(prenom) et j'ai \(age) ans."
    print(message) // Affiche : Bonjour, je m'appelle Mathieu et j'ai 20 ans.
  </code></pre>

      <h2 id="types-donnees">Les types de donn√©es</h2>
      <p>Swift propose plusieurs types de donn√©es :</p>

      <pre><code class="language-swift">
    var numero: Int     // Nombres entiers, positifs ou n√©gatifs
    var uNumero: UInt   // Nombres entiers, positifs uniquement
    var booleen: Bool   // True ou false
    var chaine: String  // Texte
    var double: Double  // Nombres d√©cimaux avec une pr√©cision double
    var flottant: Float // Nombres d√©cimaux avec une pr√©cision simple
  </code></pre>

      <h2 id="structures-conditionnelles">Structures conditionnelles</h2>
      <p>
        Swift supporte des structures conditionnelles comme
        <strong>if</strong>, <strong>else if</strong>, <strong>else</strong>,
        <strong>switch</strong>, et l'op√©rateur ternaire :
      </p>
      <pre><code class="language-swift">
    var x = 7

    // Condition avec if
    if x > 5 {
        print("x est sup√©rieur √† 5")
    }

    // Condition avec if et else
    if x > 10 {
        print("x est sup√©rieur √† 10")
    } else {
        print("x est inf√©rieur ou √©gal √† 10")
    }

    // Condition avec if, else if et else
    if x == 0 {
        print("x est nul")
    } else if x < 0 {
        print("x est n√©gatif")
    } else {
        print("x est positif")
    }

    // 

    // Op√©rateur ternaire
    var message = x > 0 ? "Positif" : "N√©gatif"

    // Switch case
    switch x {
    case 1, 2, 3:
        print("Petit nombre")
    case 7:
        print("Nombre premier")
    default:
        print("Autre")
    }
  </code></pre>

      <h2 id="boucles">Les boucles</h2>
      <p>Swift propose plusieurs types de boucles :</p>
      <pre><code class="language-swift">
    // Boucle for
    for i in 0...5 {
        print(i) // Affiche les nombres de 0 √† 5
    }
    
    for i in 0..<5 {
        print(i) // Affiche les nombres de 0 √† 4
    }

    // le underscore indique au compilateur de ne pas se preoccuper de l'affectation
    for _ in 0..<5 {
        print("Hello") // Affiche "Hello" 5 fois
    }

    // Boucle while
    var i = 0
    while i < 5 {
        print(i)
        i += 1
    }

    // Boucle repeat-while (do-while)
    var j = 0
    repeat {
        print(j)
        j += 1
    } while j < 5
  </code></pre>

      <h2 id="fonctions">Les fonctions</h2>

      <h3>Fonction sans param√®tre</h3>
      <p>
        Une fonction sans param√®tre est une fonction qui ne prend rien en
        entr√©e pour effectuer son travail. Elle ex√©cute toujours la m√™me
        action, sans avoir besoin d‚Äôinformations suppl√©mentaires.
      </p>
      <pre><code class="language-swift">
    func direBonjour() {
        print("Bonjour !")
    }

    direBonjour() // Affiche : Bonjour !
    </code></pre>

      <h3>Fonction avec param√®tres</h3>
      <p>
        Une fonction avec param√®tres est une fonction qui prend des
        informations en entr√©e pour effectuer son travail. Ces informations,
        qu‚Äôon appelle des param√®tres, permettent √† la fonction de s‚Äôadapter et
        de produire un r√©sultat diff√©rent selon ce qu‚Äôon lui donne.
      </p>
      <pre><code class="language-swift">
    func direBonjour(prenom: String) {
        print("Bonjour, \(prenom) !")
    }

    direBonjour(prenom: "Mathieu") // Affiche : Bonjour, Mathieu !
  </code></pre>

      <h3>Fonction avec valeur de retour</h3>
      <p>
        Une fonction avec valeur de retour est une fonction qui, apr√®s avoir
        ex√©cut√© son travail, renvoie un r√©sultat que l‚Äôon peut utiliser
        ailleurs dans le programme. Ce r√©sultat est appel√© la valeur de
        retour.
      </p>
      <pre><code class="language-swift">
    func additionner(a: Int, b: Int) -> Int {
        return a + b
    }

    let resultat = additionner(a: 5, b: 3)
    print(resultat) // Affiche : 8
</code></pre>

      <h3>Fonction avec param√®tres variadiques</h3>
      <p>
        Une fonction avec param√®tre variadique est une fonction qui peut
        accepter un nombre illimit√© de valeurs pour un param√®tre donn√©. Cela
        signifie qu‚Äôon peut passer autant d‚Äôarguments qu‚Äôon le souhaite pour
        ce param√®tre, sans devoir en fixer un nombre exact √† l‚Äôavance.
      </p>
      <pre><code class="language-swift">
    func moyenne(_ nombres: Double...) -> Double {
        var total = 0.0
        for nombre in nombres {
            total += nombre
        }
        return total / Double(nombres.count)
    }

    let moy = moyenne(1, 2, 3, 4, 5)
    print(moy) // Affiche : 3.0
  </code></pre>

      <h3>Fonction avec param√®tres par d√©faut</h3>
      <p>
        Une fonction avec un param√®tre par d√©faut est une fonction o√π certains
        param√®tres ont une valeur d√©j√† d√©finie si l‚Äôutilisateur n‚Äôen fournit
        pas lorsqu‚Äôil appelle la fonction. Ces valeurs par d√©faut sont
        utilis√©es automatiquement.
      </p>
      <pre><code class="language-swift">
    func direBonjour(prenom: String = "Inconnu") {
        print("Bonjour, \(prenom) !")
    }

    direBonjour() // Affiche : Bonjour, Inconnu !
    direBonjour(prenom: "Mathieu") // Affiche : Bonjour, Mathieu !
</code></pre>

      <h3>Fonction avec param√®tres inout</h3>
      <p>
        Une fonction avec param√®tres inout est une fonction qui peut modifier
        directement la valeur d‚Äôune variable pass√©e en argument. Cela
        fonctionne en permettant √† la fonction d‚Äôacc√©der √† l‚Äôint√©rieur de la
        variable au lieu d‚Äôutiliser une copie de sa valeur.
      </p>
      <pre><code class="language-swift">
    func doubler(_ nombre: inout Int) {
        nombre *= 2
    }

    var x = 10
    doubler(&x)
    print(x) // Affiche : 20
</code></pre>

      <h3>Fonction avec valeur de retour optionnelle</h3>
      <p>
        Une fonction avec valeur de retour optionnelle est une fonction qui
        peut soit :
        <li>Renvoyer une valeur (comme une fonction classique),</li>
        <li>
          Soit renvoyer rien (ou plut√¥t <strong>nil</strong>, qui signifie
          ‚Äúpas de valeur‚Äù).
        </li>
      </p>
      <p>
        Cela permet de g√©rer des cas o√π une fonction peut √©chouer ou ne pas
        avoir de r√©ponse valable.
      </p>
      <pre><code class="language-swift">
    func diviser(_ a: Double, par b: Double) -> Double? {
        if b == 0 {
            return nil
        }
        return a / b
    }

    if let resultat = diviser(10, par: 2) {
        print(resultat) // Affiche : 5.0
    } else {
        print("Division par z√©ro !")
    }
</code></pre>

      <h3>Fonction avec √©tiquettes d'argument personnalis√©es</h3>
      <p>
        Les √©tiquettes d'argument permettent de nommer les param√®tres d'une
        fonction de mani√®re plus explicite lors de son appel. Elles rendent le
        code plus lisible et plus compr√©hensible.
      </p>
      <pre><code class="language-swift">
    func direBonjour(a prenom: String) {
        print("Bonjour, \(prenom) !")
    }

    direBonjour(a: "Mathieu") // Affiche : Bonjour, Mathieu !
</code></pre>

      <h3>Fonction avec √©tiquettes d'argument omises</h3>
      <p>
        Il est possible d'omettre les √©tiquettes d'argument pour rendre le
        code plus concis. Cela est utile lorsque le nom du param√®tre est d√©j√†
        explicite.
      </p>
      <pre><code class="language-swift">
    func direBonjour(_ prenom: String) {
        print("Bonjour, \(prenom) !")
    }

    direBonjour("Mathieu") // Affiche : Bonjour, Mathieu !
</code></pre>

      <h3>Fonction avec √©tiquettes d'argument pour les param√®tres suivants</h3>
      <p>
        Il est possible de d√©finir des √©tiquettes d'argument pour les
        param√®tres suivants, afin de rendre le code plus lisible et plus
        compr√©hensible.
      </p>
      <pre><code class="language-swift">
    func additionner(_ a: Int, et b: Int) -> Int {
        return a + b
    }

    let somme = additionner(5, et: 3)
    print(somme) // Affiche : 8
</code></pre>

      <h3>
        Fonction avec √©tiquettes d'argument pour les param√®tres pr√©c√©dents
      </h3>
      <p>
        Il est possible de d√©finir des √©tiquettes d'argument pour les
        param√®tres pr√©c√©dents, afin de rendre le code plus lisible et plus
        compr√©hensible.
      </p>
      <pre><code class="language-swift">
    func additionner(a: Int, _ b: Int) -> Int {
        return a + b
    }

    let total = additionner(a: 5, 3)
    print(total) // Affiche : 8
</code></pre>

      <h2 id="structures">Les structures de donn√©es</h2>
      <p>
        Les structures de donn√©es en Swift sont des outils essentiels pour
        organiser, stocker et manipuler des informations dans un programme.
        Swift propose plusieurs structures int√©gr√©es, puissantes et flexibles,
        qui couvrent la majorit√© des besoins de d√©veloppement.
      </p>

      <h3>Les tableaux</h3>
      <p>
        Un tableau est une liste ordonn√©e d‚Äô√©l√©ments de m√™me type. Il permet
        de stocker plusieurs valeurs dans une seule variable.
      </p>

      <pre><code class="language-swift">
  var fruits: [String] = ["Pomme", "Banane", "Orange"]
  fruits.append("Mangue") // Ajouter un √©l√©ment
  fruits.remove(at: 1) // Supprimer l'√©l√©ment √† l'index 1
  print(fruits) // Affiche : ["Pomme", "Orange", "Mangue"]
  </code></pre>

      <ul>
        <li><strong>Caract√©ristiques :</strong>
          <ol>
            <li><strong>Index√©</strong> : Chaque √©l√©ment a une position sp√©cifique (commen√ßant √† 0).</li>
            <li><strong>Mutable ou immuable</strong> : D√©pend si le tableau est d√©clar√© avec <strong>var</strong>
              (modifiable) ou <strong>let</strong> (non modifiable).</li>
            <li><strong>Peut √™tre vide</strong> : var fruits: [String] = []</li>
          </ol>
      </ul>

      <h3>Les dictionnaires</h3>
      <p>
        Un dictionnaire est une collection non ordonn√©e de paires cl√©-valeur. Chaque cl√© est unique et associ√©e √† une
        valeur.
      </p>
      <pre><code class="language-swift">
  var capitales: [String: String] = ["France": "Paris", "Italie": "Rome"]
  capitales["Espagne"] = "Madrid" // Ajouter une cl√© et une valeur
  capitales["Italie"] = "Venise" // Modifier une valeur
  capitales.removeValue(forKey: "France") // Supprimer une cl√©
  print(capitales) // Affiche : ["Italie": "Venise", "Espagne": "Madrid"]
      </code></pre>

      <ul>
        <li><strong>Caract√©ristiques :</strong>
          <ol>
            <li>Rapide pour rechercher des valeurs √† partir de cl√©s.</li>
            <li>Les cl√©s peuvent √™tre de n‚Äôimporte quel type conforme √† Hashable (exemple : String, Int, etc.).</li>
          </ol>
      </ul>

      <h3>Les ensembles (set)</h3>
      <p>Un ensemble est une collection non ordonn√©e d‚Äô√©l√©ments uniques.</p>
      <pre><code class="language-swift">
  var couleurs: Set< String > = ["Rouge", "Vert", "Bleu"]
  couleurs.insert("Jaune") // Ajouter un √©l√©ment
  couleurs.remove("Vert") // Supprimer un √©l√©ment
  print(couleurs) // Affiche : ["Rouge", "Bleu", "Jaune"]
        </code></pre>

      <ul>
        <li><strong>Caract√©ristiques :</strong>
          <ol>
            <li>Les √©l√©ments sont uniques et non ordonn√©s.</li>
            <li>Utilis√© pour des op√©rations comme union, intersection ou soustraction.</li>
          </ol>
      </ul>

      <strong>Exemple d'op√©rations sur les ensembles</strong>
      <pre><code class="language-swift">
  let a: Set = [1, 2, 3]
  let b: Set = [3, 4, 5]
  print(a.union(b)) // [1, 2, 3, 4, 5] (union)
  print(a.intersection(b)) // [3] (intersection)
  print(a.subtracting(b)) // [1, 2] (soustraction)
          </code></pre>

      <h3 id="tuples">Les tuples</h3>
      <p>
        Un tuple regroupe plusieurs valeurs dans une seule entit√©. Contrairement aux tableaux, les √©l√©ments d‚Äôun tuple
        peuvent √™tre de types diff√©rents.
      </p>
      <pre><code class="language-swift">
  let personne = ("Alice", 25, true)
  print(personne.0) // Affiche : Alice
  print(personne.1) // Affiche : 25
  print(personne.2) // Affiche : true
          </code></pre>
      <ul>
        <li><strong>Caract√©ristiques :</strong>
          <ol>
            <li>Peut contenir des valeurs de types diff√©rents.</li>
            <li>Les √©l√©ments d‚Äôun tuple peuvent √™tre nomm√©s ou non.</li>
          </ol>
      </ul>

      <strong>Exemple de tuple nomm√©</strong>
      <pre><code class="language-swift">
  let personne = (nom: "Alice", age: 25, estEtudiante: true)
  print(personne.nom) // Affiche : Alice
            </code></pre>

      <h2 id="struct">Structures personnalis√©es (struct)</h2>
      <p>
        Les structures (struct) sont l‚Äôun des types fondamentaux en Swift. Elles permettent de d√©finir des types
        personnalis√©s qui peuvent contenir des propri√©t√©s (variables et constantes) et des m√©thodes (fonctions). Les
        struct sont largement utilis√©es pour organiser des donn√©es et ajouter des fonctionnalit√©s dans un programme
        Swift.
      </p>
      <ul>
        <li><strong>Caract√©ristiques des struct:</strong>
          <ol>
            <li>Valeur (Value Type) :
              <ul>
                <li>
                  En Swift, les structures sont des types valeur, ce qui signifie que lorsque vous les assignez √† une
                  variable ou les passez √† une fonction, elles sont copi√©es au lieu d‚Äô√™tre r√©f√©renc√©es.
                </li>
              </ul>
            </li>
            <li>
              Propri√©t√©s :
              <ul>
                <li>
                  Une structure peut avoir des propri√©t√©s stock√©es (valeurs) et des propri√©t√©s calcul√©es.
                </li>
              </ul>
            </li>
            <li>
              M√©thodes :
              <ul>
                <li>
                  Les structures peuvent inclure des fonctions qui agissent sur leurs propri√©t√©s. </li>
              </ul>
            </li>
            <li>
              Initialisation :
              <ul>
                <li>
                  Swift g√©n√®re automatiquement un initialiseur par d√©faut pour les structures si toutes les propri√©t√©s
                  sont initialis√©es.
                </li>
              </ul>
            </li>
            <li>
              Conformit√© aux Protocoles :
              <ul>
                <li>
                  Les struct peuvent adopter des protocoles pour garantir qu‚Äôelles respectent certaines exigences.
                </li>
            </li>
          </ol>
      </ul>

      <h3>D√©claration et Utilisation des struct</h3>
      <pre><code class="language-swift">
  struct Point {
    var x: Double
    var y: Double
    
    // M√©thode pour d√©placer le point
    mutating func move(dx: Double, dy: Double) {
        x += dx
        y += dy
    }
  }
  
  // Cr√©ation d'une instance
  var point = Point(x: 3.0, y: 4.0)
  
  // Affichage des coordonn√©es
  print("Point initial : (\(point.x), \(point.y))")
  
  // D√©placement du point
  point.move(dx: 2.0, dy: -1.0)
  print("Point apr√®s d√©placement : (\(point.x), \(point.y))")
      </code></pre>

      <strong>Exemple de struct avec initialisateur personnalis√©</strong>
      <pre><code class="language-swift">
  struct Rectangle {
    var width: Double
    var height: Double
    
    // Initialiseur personnalis√©
    init(width: Double, height: Double) {
        self.width = width
        self.height = height
    }
    
    // Calcul de l'aire (propri√©t√© calcul√©e)
    var area: Double {
        return width * height
    }
  }
  
  let rectangle = Rectangle(width: 5.0, height: 10.0)
  print("Aire du rectangle : \(rectangle.area)")
      </code></pre>

      <strong>Immutabilit√© et propri√©t√©s mutables</strong>
      <p>Une instance d‚Äôune structure d√©finie comme <strong>let</strong> est immutable. Les propri√©t√©s ne peuvent pas
        √™tre modifi√©es.</p>
      <pre><code class="language-swift">
  let immutablePoint = Point(x: 1.0, y: 2.0)
  immutablePoint.x = 5.0 // Erreur : Impossible de modifier une propri√©t√© d'une instance constante
      </code></pre>

      <strong>Structures imbriqu√©es</strong>
      <p>Une structure peut contenir d‚Äôautres structures. Par exemple, un rectangle peut √™tre d√©fini √† partir de deux
        points.</p>
      <pre><code class="language-swift">
  struct Point {
    var x: Double
    var y: Double
  }
  
  struct Rectangle {
      var topLeft: Point
      var bottomRight: Point
      
      var area: Double {
          let width = bottomRight.x - topLeft.x
          let height = bottomRight.y - topLeft.y
          return width * height
      }
  }
      
  let rect = Rectangle(topLeft: Point(x: 0, y: 10), bottomRight: Point(x: 5, y: 0))
  print("Aire du rectangle : \(rect.area)")
    </code></pre>

      <h2 id="classes">Les classes</h2>
      <p>
        Les classes sont des types de donn√©es de base en Swift, qui permettent de cr√©er des objets avec des propri√©t√©s
        et
        des m√©thodes. Les classes sont des types r√©f√©rence, ce qui signifie que lorsqu‚Äôon les assigne √† une variable ou
        qu‚Äôon les passe √† une fonction, elles sont partag√©es plut√¥t que copi√©es.
      </p>
      <ul>
        <li><strong>Caract√©ristiques des class:</strong>
          <ol>
            <li>Type R√©f√©rence :
              <ul>
                <li>
                  Les instances de classe sont partag√©es. Les modifications faites √† une r√©f√©rence affectent toutes les
                  autres r√©f√©rences pointant vers la m√™me instance.
                </li>
              </ul>
            </li>
            <li>
              H√©ritage :
              <ul>
                <li>
                  Les classes peuvent h√©riter les propri√©t√©s, m√©thodes et initialiseurs d‚Äôune autre classe.
                </li>
              </ul>
            </li>
            <li>
              D√©initialiseurs :
              <ul>
                <li>
                  Les classes peuvent inclure un deinit pour effectuer un nettoyage avant que l‚Äôinstance ne soit
                  lib√©r√©e.</li>
              </ul>
            </li>
            <li>
              Mutabilit√© :
              <ul>
                <li>
                  Les propri√©t√©s peuvent √™tre modifi√©es m√™me si l‚Äôinstance est d√©clar√©e avec let, sauf si elles sont
                  marqu√©es comme constantes (let dans la classe).
                </li>
              </ul>
            </li>
            <li>
              Conformit√© aux protocoles :
              <ul>
                <li>
                  Comme les struct, les classes peuvent adopter des protocoles pour garantir qu‚Äôelles respectent
                  certaines exigences.
                </li>
            </li>
          </ol>
      </ul>

      <pre><code class="language-swift">
  class Personne {
    var prenom: String
    var age: Int

    init(prenom: String, age: Int) {
        self.prenom = prenom
        self.age = age
    }

    func direBonjour() {
        print("Bonjour, je m'appelle \(prenom) et j'ai \(age) ans.")
    }
  }
  
  let personne = Personne(prenom: "Mathieu", age: 20)
  personne.direBonjour() // Affiche : Bonjour, je m'appelle Mathieu et j'ai 20 ans.

  personne.age = 27
  personne.direBonjour() // Affiche : Bonjour, je m'appelle Mathieu et j'ai 27 ans.
    </code></pre>

      <h3>H√©ritage</h3>
      <p>
        Une classe peut h√©riter d‚Äôune autre classe pour partager et √©tendre ses fonctionnalit√©s.
      </p>
      <pre><code class="language-swift">
  class Animal {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func makeSound() {
        print("\(name) fait un bruit.")
    }
  }
  
  // Classe d√©riv√©e
  class Dog: Animal {
    func bark() {
        print("\(name) aboie.")
    }
    
    // Red√©finition d'une m√©thode
    override func makeSound() {
        print("\(name) fait : Woof!")
    }
  }
    
  let dog = Dog(name: "Rex")
  dog.makeSound()
  dog.bark()
    </code></pre>

      <h3>D√©initialiseur</h3>
      <p>
        Un d√©initialiseur (deinit) est une m√©thode sp√©ciale utilis√©e dans les classes pour ex√©cuter du code juste avant
        que l‚Äôinstance de la classe ne soit d√©truite. Cela permet de lib√©rer des ressources, fermer des connexions ou
        effectuer un nettoyage n√©cessaire.
      </p>
      <ul>
        <li>
          <strong>Caract√©ristiques principales :</strong>
          <ol>
            <li>
              <strong>Uniquement pour les classes</strong> : Les d√©initialiseurs ne sont pas disponibles pour les struct
              ou enum.
            </li>
            <li>
              <strong>Automatique</strong> : Le d√©initialiseur est appel√© automatiquement par le syst√®me de gestion de
              m√©moire de Swift (ARC) lorsque l‚Äôinstance n‚Äôest plus r√©f√©renc√©e.
            </li>
            <li>
              <strong>Sans param√®tres ni retour</strong> : Vous ne pouvez pas passer d‚Äôarguments ou retourner une valeur
              depuis un d√©initialiseur.
            </li>
          </ol>
        </li>
      </ul>

      <strong>Syntaxe d‚Äôun d√©initialiseur</strong>
      <pre><code class="language-swift">
  deinit {
    // Code de nettoyage
  }
    </code></pre>

      <strong>Exemple : gestion de ressources</strong>
      <pre><code class="language-swift">
  class FileHandler {
    var fileName: String
    
    init(fileName: String) {
        self.fileName = fileName
        print("Fichier \(fileName) ouvert.")
    }
    
    deinit {
        print("Fichier \(fileName) ferm√©.")
    }
  }
  
  // Bloc pour limiter la port√©e
  do {
    let handler = FileHandler(fileName: "document.txt")
    // √Ä la fin du bloc, handler est lib√©r√© et le d√©initialiseur est appel√©
  }
    </code></pre>

      <p>
        Le d√©initialiseur est utile pour g√©rer la m√©moire et nettoyer les ressources associ√©es √† une instance
        lorsqu‚Äôelle est d√©truite. Swift s‚Äôen charge automatiquement via l‚ÄôARC, mais le d√©initialiseur permet d‚Äôajouter
        un traitement sp√©cifique si n√©cessaire.
      </p>

      <h2 id="optionnels">Les optionnels</h2>
      <p>
        Les optionnels sont une fonctionnalit√© cl√© de Swift qui permet de g√©rer les valeurs manquantes ou inexistantes.
        Ils sont utilis√©s pour indiquer qu‚Äôune variable ou une constante peut soit contenir une valeur, soit √™tre nulle
        (nil). Cela offre une mani√®re s√ªre et explicite de travailler avec des donn√©es qui peuvent √™tre absentes, tout
        en √©vitant les erreurs courantes li√©es √† des pointeurs nuls.
      </p>
      <ul>
        <li>
          <strong>Avantages des optionnels</strong>
          <ol>
            <li><strong>S√©curit√©</strong> : Les optionnels √©vitent les plantages li√©s √† l‚Äôutilisation de variables nil.
            </li>
            <li><strong>Lisibilit√©</strong> : Le code est explicite quant √† la possibilit√© d‚Äôabsence de valeur.</li>
            <li><strong>Contr√¥le</strong> : Vous avez plusieurs m√©canismes pour g√©rer et valider les valeurs manquantes.
            </li>
          </ol>
        </li>
      </ul>

      <h3>D√©claration d‚Äôun optionnel</h3>
      <p>
        Un optionnel est d√©clar√© en ajoutant un point d‚Äôinterrogation (?) apr√®s le type de la variable.
      </p>
      <pre><code class="language-swift">
  var name: String?  // Peut contenir une valeur de type String ou √™tre nil
  name = "Alice"     // Contient une valeur
  name = nil         // Maintenant, aucune valeur n'est pr√©sente
    </code></pre>

      <h3>Acc√®s aux valeurs optionnelles</h3>
      <p>
        Pour utiliser la valeur d‚Äôun optionnel, il faut d‚Äôabord la ‚Äúd√©baller‚Äù (unwrap). Il existe plusieurs fa√ßons de le
        faire.
      </p>

      <strong>D√©ballage forc√© (!)</strong>
      <p>
        Utilis√© lorsque vous √™tes certain que l‚Äôoptionnel contient une valeur. Cependant, si l‚Äôoptionnel est nil, cela
        provoque une erreur √† l‚Äôex√©cution.
      </p>
      <pre><code class="language-swift">
  var name: String? = "Alice"
  print(name!)  // Affiche "Alice"
      </code></pre>

      <p>‚ö†Ô∏è <strong style="color: red; font-size: larger;">Attention</strong> : √âvitez d‚Äôutiliser le d√©ballage forc√© √†
        moins d‚Äô√™tre s√ªr √† <strong>100%</strong> que l‚Äôoptionnel n‚Äôest pas nil.</p>

      <strong>D√©ballage conditionnel (if let)</strong>
      <p>
        Permet de v√©rifier si une valeur est pr√©sente et de la d√©baller de mani√®re s√©curis√©e.
      </p>
      <pre><code class="language-swift">
  var name: String? = "Alice"
  if let unwrappedName = name {
      print("Bonjour, \(unwrappedName)!")
  } else {
      print("Aucun nom fourni.")
  }
      </code></pre>

      <strong>D√©ballage avec guard let</strong>
      <p>
        Utilis√© pour forcer une valeur non-nil dans une fonction ou un bloc de code et quitter si la condition √©choue.
      </p>
      <pre><code class="language-swift">
  func greetUser(name: String?) {
    guard let unwrappedName = name else {
        print("Nom manquant.")
        return
    }
    print("Bonjour, \(unwrappedName)!")
  }    
      </code></pre>

      <strong>Op√©rateur de coalescence (??)</strong>
      <p>
        Permet de fournir une valeur par d√©faut si l‚Äôoptionnel est nil.
      </p>
      <pre><code class="language-swift">
  let username: String? = nil
  let displayName = username ?? "Utilisateur inconnu"
  print(displayName)  // Affiche "Utilisateur inconnu"
      </code></pre>

      <strong>Optionnels implicites</strong>
      <p>
        Si une valeur optionnelle est garantie d‚Äôavoir une valeur apr√®s son initialisation, on peut utiliser un
        optionnel implicite en ajoutant un point d‚Äôexclamation (!) apr√®s le type.
      </p>
      <pre><code class="language-swift">
  var email: String! = "test@example.com"
  print(email)  // Pas besoin de d√©ballage explicite
      </code></pre>

      <p>‚ö†Ô∏è <strong style="color: red; font-size: larger;">Attention</strong> : Cependant, l‚Äôutilisation des optionnels
        implicites doit √™tre limit√©e, car elle comporte les m√™mes risques que le d√©ballage forc√©.</p>

      <h2 id="protocole">Protocole</h2>
      <p>
        En Swift, un protocole est un mod√®le (ou contrat) qui d√©finit un ensemble de propri√©t√©s, m√©thodes, ou autres
        exigences qu‚Äôune classe, une structure, ou une √©num√©ration doit impl√©menter. Les protocoles permettent
        d‚Äôorganiser le code, de garantir un comportement uniforme entre les types, et de faciliter l‚Äôutilisation du
        polymorphisme.
      </p>

      <h3>D√©claration d‚Äôun protocole</h3>
      <p>
        Un protocole est d√©clar√© √† l‚Äôaide du mot-cl√© <strong>protocol</strong>, suivi de son nom et de ses exigences.
      </p>
      <pre><code class="language-swift">
  protocol Vehicule {
    var nombreDeRoues: Int { get }
    func demarrer()
  }
      </code></pre>
      <ul>
        <li>
          <strong>Propri√©t√©s</strong>
          <ol>
            <li>
              var nombreDeRoues: Int { get } signifie que tout type qui adopte ce protocole doit avoir une propri√©t√©
              nomm√©e nombreDeRoues en lecture seule.
            </li>
            <li>
              Si tu utilises { get set }, la propri√©t√© doit √™tre lisible et modifiable.
            </li>
          </ol>
        </li>
        <li>
          <strong>M√©thodes</strong>
          <ol>
            <li>
              func demarrer() indique que tout type adoptant ce protocole doit impl√©menter une m√©thode nomm√©e demarrer.
            </li>
          </ol>
        </li>
      </ul>

      <h3>Adoption d‚Äôun protocole</h3>
      <p>
        Une classe, une structure ou une √©num√©ration peut adopter un protocole en impl√©mentant ses exigences.
      </p>
      <pre><code class="language-swift">
  struct Voiture: Vehicule {
    var nombreDeRoues: Int = 4
    
    func demarrer() {
        print("La voiture d√©marre !")
    }
  }
  
  let maVoiture = Voiture()
  maVoiture.demarrer() // Affiche : La voiture d√©marre !
      </code></pre>

      <h3>Protocoles avec propri√©t√©s mutables</h3>
      <p>
        Si une propri√©t√© doit √™tre modifiable par une classe ou une structure adoptant le protocole, ajoute { get set }.
      </p>
      <pre><code class="language-swift">
  protocol Personne {
    var nom: String { get set }
    func sePresenter()
  }
  
  struct Etudiant: Personne {
    var nom: String
    
    func sePresenter() {
        print("Bonjour, je m'appelle \(nom) !")
    }
  }

  var etudiant = Etudiant(nom: "Alice")
  etudiant.sePresenter() // Affiche : Bonjour, je m'appelle Alice !
      </code></pre>

      <h3>Utiliser des protocoles comme types</h3>
      <p>
        Un protocole peut √™tre utilis√© comme type pour une variable, une constante ou un param√®tre.
      </p>
      <pre><code class="language-swift">
  func afficherDetails(vehicule: Vehicule) {
    print("Nombre de roues : \(vehicule.nombreDeRoues)")
    vehicule.demarrer()
  }
  
  let voiture = Voiture()
  afficherDetails(vehicule: voiture)
  // Affiche :
  // Nombre de roues : 4
  // La voiture d√©marre !
      </code></pre>

      <h3>H√©ritage de protocoles</h3>
      <p>
        Un protocole peut h√©riter d‚Äôun ou plusieurs autres protocoles
      </p>
      <pre><code class="language-swift">
  protocol VehiculeMotorise: Vehicule {
    var typeDeCarburant: String { get }
  }
  
  struct Moto: VehiculeMotorise {
    var nombreDeRoues: Int = 2
    var typeDeCarburant: String = "Essence"
    
    func demarrer() {
        print("La moto d√©marre !")
    }
  }
  
  let moto = Moto()
  print(moto.typeDeCarburant) // Affiche : Essence
      </code></pre>
    </section>
  </div>
  <footer class="footer">
    <p>D√©velopp√© par <a href="https://github.com/mathrob" style="color: white; text-decoration: underline;">Mathieu
        Robson</a> &copy; <span id="current-year"></span></p>
    <script>
      document.getElementById("current-year").textContent =
        new Date().getFullYear();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </footer>
  <div class="back-to-top" id="back-to-top">‚Üë</div>
  <script>
    const backToTopButton = document.getElementById("back-to-top");

    window.addEventListener("scroll", () => {
      if (window.scrollY > 300) {
        backToTopButton.style.display = "block";
      } else {
        backToTopButton.style.display = "none";
      }
    });

    backToTopButton.addEventListener("click", () => {
      window.scrollTo({
        top: 0,
        behavior: "smooth",
      });
    });
  </script>
</body>

</html>