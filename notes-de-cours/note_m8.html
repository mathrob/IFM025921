<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IFM025921</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
    <link rel="stylesheet" href="../style.css" />
</head>

<body>
    <header>
        <h1 style="color: white">Module 8 - Note de cours</h1>
    </header>
    <div class="container">
        <a href="../index.html" class="back-link">‚Üê Retour au module principal</a>

        <section id="module-8-1" class="module-section">
            <h1 id="grilles">Cr√©ation de grilles avec LazyVGrid et LazyHGrid</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/t4Kbg4UnMPc" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <h2>Introduction</h2>
            <h3>Pourquoi utiliser des grilles ü§î</h3>
            <p>
                Dans une application iOS, il est souvent n√©cessaire d‚Äôafficher des donn√©es sous forme de tableau ou de
                collection d‚Äô√©l√©ments visuels align√©s. Par exemple :
            </p>
            <ul>
                <li> ‚Ä¢ Un catalogue de produits dans une boutique en ligne.</li>
                <li> ‚Ä¢ Une galerie d‚Äôimages.</li>
                <li> ‚Ä¢ Un tableau de scores dans une application de jeux.</li>
                <li> ‚Ä¢ Un calendrier avec des jours r√©partis sur plusieurs colonnes.</li>
            </ul>
            <p>
                Les stacks (HStack, VStack) et les Listes (List) permettent d‚Äôafficher des √©l√©ments en ligne ou en
                colonne, mais ils ne sont pas adapt√©s pour organiser des donn√©es en grille.
            </p>
            <p>
                SwiftUI propose donc <strong>LazyVGrid</strong> et <strong>LazyHGrid</strong>, deux vues permettant
                d‚Äôorganiser le contenu sous forme de grille tout en optimisant les performances.
            </p>

            <h2>Comprendre LazyVGrid et LazyHGrid</h2>
            <h3>Qu‚Äôest-ce qu‚Äôune grille paresseuse ü§î</h3>
            <p>
                Les vues LazyVGrid et LazyHGrid sont dites paresseuses (lazy) car elles ne cr√©ent des cellules que
                lorsque celles-ci sont visibles √† l‚Äô√©cran. D√®s qu‚Äôune cellule dispara√Æt de l‚Äô√©cran (par exemple en
                faisant d√©filer la liste), SwiftUI la supprime temporairement pour √©conomiser la m√©moire et am√©liorer
                les performances.
            </p>
            <p>
                Cela permet d‚Äôafficher un nombre potentiellement infini d‚Äô√©l√©ments sans ralentir l‚Äôapplication.
            </p>

            <h4>Diff√©rence entre LazyVGrid et LazyHGrid</h4>
            <table border="1" style="border-collapse: collapse;">
                <thead>
                    <tr>
                        <th style="padding: 4px;">LazyVGrid</th>
                        <th style="padding: 4px;">LazyHGrid</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 4px;">Organise les √©l√©ments en colonnes</td>
                        <td style="padding: 4px;">Organise les √©l√©ments en lignes</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">D√©filement vertical</td>
                        <td style="padding: 4px;">D√©filement horizontal</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Utilise une liste de GridItem pour d√©finir les colonnes</td>
                        <td style="padding: 4px;">Utilise une liste de GridItem pour d√©finir les lignes</td>
                    </tr>
                </tbody>
            </table>

            <h3>Syntaxe de base</h3>
            <p>
                Une <strong>LazyVGrid</strong> s‚Äô√©crit comme ceci :
            </p>
            <pre><code class="swift">LazyVGrid(
    columns: [GridItem],   // D√©finition des colonnes
    alignment: .center,    // Alignement horizontal des √©l√©ments (optionnel)
    spacing: 10,           // Espacement entre les √©l√©ments (optionnel)
    pinnedViews: []        // √âl√©ments "pinn√©s" (optionnel)
) {
    // Contenu de la grille
}
</code></pre>

            <p>
                Une <strong>LazyHGrid</strong> s‚Äô√©crit de mani√®re similaire, mais en d√©finissant des lignes plut√¥t que
                des colonnes :
            </p>
            <pre><code class="swift">LazyHGrid(
    rows: [GridItem],      // D√©finition des lignes
    alignment: .top,       // Alignement vertical des √©l√©ments (optionnel)
    spacing: 10,           // Espacement entre les √©l√©ments (optionnel)
    pinnedViews: []        // √âl√©ments "pinn√©s" (optionnel)
) {
    // Contenu de la grille
}
</code></pre>

            <h3>Les GridItems : D√©finition des colonnes et des lignes</h3>
            <p>
                GridItem est utilis√© pour d√©finir comment les colonnes (dans une LazyVGrid) ou les lignes (dans une
                LazyHGrid) doivent √™tre configur√©es.
            </p>
            <h4>Il existe trois types de GridItem :</h4>
            <table border="1" style="border-collapse: collapse;">
                <thead>
                    <tr>
                        <th style="padding: 4px;">Type de GridItem</th>
                        <th style="padding: 4px;">Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 4px;">.fixed(CGFloat)</td>
                        <td style="padding: 4px;">D√©finit une colonne/ligne de largeur/hauteur fixe.</td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.flexible(minimum: CGFloat, maximum: CGFloat)</td>
                        <td style="padding: 4px;">Ajuste dynamiquement la taille en fonction de l‚Äôespace disponible.
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">.adaptive(minimum: CGFloat)</td>
                        <td style="padding: 4px;">Cr√©e autant de colonnes/lignes que possible, respectant une taille
                            minimale.</td>
                    </tr>
                </tbody>
            </table>

            <h4>Exemples de GridItems</h4>
            <p>
                Grille avec trois colonnes de largeur fixe (100 points chacune) :
            </p>
            <pre><code class="swift">let gridItems = [
    GridItem(.fixed(100)),
    GridItem(.fixed(100)),
    GridItem(.fixed(100))
]</code></pre>

            <p>
                Grille avec trois colonnes flexibles (r√©partition √©quitable de l‚Äôespace disponible) :
            </p>
            <pre><code class="swift">let gridItems = [
    GridItem(.flexible()),
    GridItem(.flexible()),
    GridItem(.flexible())
]
</code></pre>

            <p>
                Grille adaptative (autant de colonnes que possible, largeur min. de 50 points) :
            </p>
            <pre><code class="swift">let gridItems = [
    GridItem(.adaptive(minimum: 50))
]
</code></pre>

            <h3>Exemple d‚Äôimpl√©mentation d‚Äôune LazyVGrid</h3>
            <p>
                Cr√©ons une grille contenant 9 cellules color√©es.
            </p>
            <pre><code class="swift">import SwiftUI

struct ContentView: View {
    private let colors: [Color] = [.blue, .yellow, .green]

    // D√©finition des colonnes
    private let gridItems = [
        GridItem(.flexible()),
        GridItem(.flexible()),
        GridItem(.flexible())
    ]

    var body: some View {
        LazyVGrid(columns: gridItems, spacing: 5) {
            ForEach(0..<9, id: \.self) { index in
                Text("\(index)")
                    .frame(minWidth: 50, maxWidth: .infinity, minHeight: 100)
                    .background(colors[index % colors.count])
                    .cornerRadius(8)
                    .font(.system(size: 24, weight: .bold))
            }
        }
        .padding()
    }
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li> ‚Ä¢ On d√©finit une grille avec trois colonnes flexibles (GridItem(.flexible())).</li>
                <li> ‚Ä¢ La boucle ForEach g√©n√®re 9 √©l√©ments num√©rot√©s de 0 √† 8.</li>
                <li> ‚Ä¢ Chaque √©l√©ment a un fond color√©, une taille d√©finie et un texte affichant son index.</li>
            </ul>

            <h3>Ajout du d√©filement avec ScrollView</h3>
            <p>
                Si le nombre d‚Äô√©l√©ments d√©passe la taille de l‚Äô√©cran, il est n√©cessaire d‚Äôajouter un
                <strong>ScrollView</strong> pour permettre le d√©filement :
            </p>
            <pre><code class="swift">var body: some View {
    ScrollView {
        LazyVGrid(columns: gridItems, spacing: 5) {
            ForEach(0..<99, id: \.self) { index in
                Text("\(index)")
                    .frame(minWidth: 50, maxWidth: .infinity, minHeight: 100)
                    .background(colors[index % colors.count])
                    .cornerRadius(8)
                    .font(.system(size: 24, weight: .bold))
            }
        }
        .padding()
    }
}
</code></pre>

            <h4>Pourquoi utiliser un ScrollView ?</h4>
            <p>
                Sans ScrollView, seuls les √©l√©ments visibles sur l‚Äô√©cran s‚Äôafficheraient et nous ne pourrions pas voir
                les autres.
            </p>

            <h3>Exemple d‚Äôutilisation de LazyHGrid</h3>

            <p>Voici un exemple de grille horizontale avec d√©filement :</p>
            <pre><code class="swift">struct ContentView: View {
    private let colors: [Color] = [.red, .orange, .purple]
    private let gridItems = [GridItem(.adaptive(minimum: 50))]

    var body: some View {
        ScrollView(.horizontal) {
            LazyHGrid(rows: gridItems, spacing: 5) {
                ForEach(0..<20, id: \.self) { index in
                    Text("\(index)")
                        .frame(minWidth: 75, minHeight: 50, maxHeight: .infinity)
                        .background(colors[index % colors.count])
                        .cornerRadius(8)
                        .font(.system(size: 24, weight: .bold))
                }
            }
            .padding()
        }
    }
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li> ‚Ä¢ On d√©finit une grille horizontale (LazyHGrid).</li>
                <li> ‚Ä¢ GridItem(.adaptive(minimum: 50)) permet d‚Äôavoir autant de lignes que n√©cessaire.</li>
                <li> ‚Ä¢ ScrollView(.horizontal) permet de faire d√©filer la grille horizontalement.</li>
            </ul>

            <h2>Conclusion</h2>
            <ul>
                <li> ‚Ä¢ LazyVGrid et LazyHGrid sont des outils puissants pour afficher du contenu en grille.</li>
                <li> ‚Ä¢ Les GridItems permettent de contr√¥ler la disposition des cellules (fixe, flexible, adaptatif).
                </li>
                <li> ‚Ä¢ L‚Äôint√©gration d‚Äôun ScrollView permet d‚Äôafficher de nombreux √©l√©ments sans contrainte d‚Äôespace.
                </li>
            </ul>
            </ul>
        </section>

        <section id="module-8-2" class="module-section">
            <h1 id="grid">Grilles avanc√©es avec Grid et GridRow</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/mWMKvB2s2IQ" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <h2>Introduction</h2>
            <p>
                Dans SwiftUI, nous avons vu que LazyVGrid et LazyHGrid permettent de cr√©er des grilles dynamiques et
                performantes. Cependant, elles ne sont pas id√©ales lorsque l‚Äôon souhaite une mise en page plus flexible
                avec un alignement plus pr√©cis des cellules.
            </p>

            <p>
                Dans <strong>iOS 17</strong>, Apple a introduit Grid et GridRow, qui permettent :
            </p>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ D‚Äôaligner les cellules avec plus de contr√¥le.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ D‚Äôavoir des cellules qui s‚Äô√©tendent sur plusieurs colonnes
                    (col-spanning).</li>
                <li style="margin-left: 30px;"> ‚Ä¢ D‚Äôajouter des cellules vides pour organiser les grilles de mani√®re
                    irr√©guli√®re.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ De mieux g√©rer l‚Äôalignement vertical et horizontal des cellules.</li>
            </ul>

            <p>
                Contrairement √† LazyVGrid et LazyHGrid, les grilles Grid et GridRow ne sont pas optimis√©es pour le
                d√©filement. Elles sont plus adapt√©es aux grilles statiques, comme :
            </p>

            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Un tableau de donn√©es</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Un calendrier</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Un tableau de scores</li>
                <li style="margin-left: 30px;"> ‚Ä¢ Une interface de mise en page sp√©cifique</li>
            </ul>

            <h2>Structure de base d‚Äôune grille avec Grid et GridRow</h2>
            <h3>Syntaxe de base :</h3>
            <p>
                Une <strong>Grid</strong> est une vue conteneur qui organise ses √©l√©ments en lignes (GridRow).
                Chaque <strong>GridRow</strong> contient plusieurs cellules, qui sont plac√©es dans des colonnes.
            </p>
            <pre><code class="swift">Grid {
    GridRow {
        // Cellules de la premi√®re ligne
    }
    GridRow {
        // Cellules de la deuxi√®me ligne
    }
    GridRow {
        // Cellules de la troisi√®me ligne
    }
}
</code></pre>
            <p>
                üìù Contrairement √† LazyVGrid, on ne d√©finit pas explicitement les colonnes. Elles sont cr√©√©es
                automatiquement en fonction du nombre d‚Äô√©l√©ments pr√©sents dans chaque ligne.
            </p>

            <h2>Exemple de grille simple</h2>
            <p>
                Voici une grille de 3 lignes et 5 colonnes qui affiche des nombres :
            </p>
            <pre><code class="swift">import SwiftUI

struct ContentView: View {
    var body: some View {
        Grid {
            GridRow {
                ForEach(1...5, id: \.self) { index in
                    CellContent(index: index, colour: .red)
                }
            }
            GridRow {
                ForEach(6...10, id: \.self) { index in
                    CellContent(index: index, colour: .blue)
                }
            }
            GridRow {
                ForEach(11...15, id: \.self) { index in
                    CellContent(index: index, colour: .green)
                }
            }
        }
        .padding()
    }
}

// Vue r√©utilisable pour les cellules
struct CellContent: View {
    var index: Int
    var colour: Color

    var body: some View {
        Text("\(index)")
            .frame(minWidth: 50, maxWidth: .infinity, minHeight: 100)
            .background(colour)
            .cornerRadius(8)
            .font(.system(.largeTitle))
    }
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li style="margin-left: 30px;">‚úî Chaque GridRow d√©finit une ligne contenant plusieurs cellules.</li>
                <li style="margin-left: 30px;">‚úî Grid est le conteneur principal.</li>
                <li style="margin-left: 30px;">‚úî Les cellules sont g√©n√©r√©es avec une boucle ForEach.</li>
                <li style="margin-left: 30px;">‚úî CellContent est une vue r√©utilisable qui affiche un chiffre et une
                    couleur.</li>
            </ul>

            <h2>Ajouter une cellule occupant toute une ligne</h2>
            <p>
                Une cellule plac√©e en dehors d‚Äôun GridRow s‚Äô√©tendra automatiquement sur toute la largeur de la grille.
            </p>
            <h4>Exemple : ajout d‚Äôune cellule occupant toute la ligne 4 :</h4>
            <pre><code class="swift">struct ContentView: View {
var body: some View {
    Grid {
        GridRow {
            ForEach(1...5, id: \.self) { index in
                CellContent(index: index, colour: .red)
            }
        }
        GridRow {
            ForEach(6...10, id: \.self) { index in
                CellContent(index: index, colour: .blue)
            }
        }
        GridRow {
            ForEach(11...15, id: \.self) { index in
                CellContent(index: index, colour: .green)
            }
        }
        // Une cellule occupant toute la largeur
        CellContent(index: 16, colour: .orange)
    }
    .padding()
}
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li style="margin-left: 30px;">‚Ä¢ La derni√®re cellule n‚Äôest pas dans un GridRow, donc elle occupe toute
                    la ligne.</li>
            </ul>

            <h2>Gestion automatique des cellules vides</h2>
            <p>
                Contrairement √† LazyVGrid, o√π chaque ligne doit avoir le m√™me nombre de colonnes, Grid ajoute
                automatiquement des cellules vides si n√©cessaire.
            </p>

            <h4>Exemple : une ligne avec moins de colonnes :</h4>
            <pre><code class="swift">Grid {
    GridRow {
        ForEach(1...5, id: \.self) { index in
            CellContent(index: index, colour: .red)
        }
    }
    GridRow {
        ForEach(6...8, id: \.self) { index in
            CellContent(index: index, colour: .blue)
        }
    }
}
</code></pre>
            <p>
                üìù Ici, la deuxi√®me ligne a seulement 3 cellules.
                SwiftUI ajoutera automatiquement 2 cellules vides pour respecter l‚Äôalignement.
            </p>

            <h2>Ajouter manuellement des cellules vides</h2>
            <p>
                On peut aussi ins√©rer des cellules vides en utilisant Color.clear et .gridCellUnsizedAxes().
            </p>
            <h4>
                Exemple : des colonnes vides aux positions paires :
            </h4>
            <pre><code class="swift">GridRow {
    ForEach(1...5, id: \.self) { index in
        if index % 2 == 1 {
            CellContent(index: index, colour: .red)
        } else {
            Color.clear
                .gridCellUnsizedAxes([.horizontal, .vertical])
        }
    }
}
</code></pre>

            <h4>Explication :</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Les colonnes paires contiennent une cellule vide (Color.clear).</li>
                <li style="margin-left: 30px;"> ‚Ä¢ .gridCellUnsizedAxes([.horizontal, .vertical]) permet d‚Äô√©viter que la
                    cellule affecte l‚Äôalignement.</li>
            </ul>

            <h2>Fusion de colonnes (Col-Spanning)</h2>
            <p>
                Une cellule peut s‚Äô√©tendre sur plusieurs colonnes gr√¢ce √† .gridCellColumns().
            </p>
            <h4>
                Exemple : deux cellules occupant plusieurs colonnes :
            </h4>
            <pre><code class="swift">GridRow {
    CellContent(index: 17, colour: .orange)
        .gridCellColumns(2) // Occupe 2 colonnes
    CellContent(index: 18, colour: .indigo)
        .gridCellColumns(3) // Occupe 3 colonnes
}
</code></pre>
            <h4>Explication :</h4>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ La premi√®re cellule occupe 2 colonnes.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ La deuxi√®me cellule occupe 3 colonnes.</li>
            </ul>

            <h2>Gestion de l‚Äôalignement</h2>
            <p>SwiftUI permet d‚Äôaligner les cellules au sein de la grille.</p>

            <h4>Alignement global de la grille :</h4>
            <pre><code class="swift">Grid(alignment: .topLeading) {
</code></pre>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ .topLeading : Aligne en haut √† gauche.</li>
                <li style="margin-left: 30px;"> ‚Ä¢ .bottomTrailing : Aligne en bas √† droite.</li>
            </ul>

            <h4>Alignement d‚Äôune ligne sp√©cifique :</h4>
            <pre><code class="swift">GridRow(alignment: .bottom) {
</code></pre>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Permet d‚Äôaligner le contenu de cette ligne uniquement.</li>
            </ul>

            <h4>Alignement d‚Äôune seule colonne :</h4>
            <pre><code class="swift">GridRow(alignment: .bottom) {
</code></pre>
            <ul>
                <li style="margin-left: 30px;"> ‚Ä¢ Alignement trailing (droite) pour cette colonne.</li>
            </ul>

            <h2>Conclusion</h2>
            <ul>
                <li style="margin-left: 30px;">‚úÖ Grid et GridRow sont parfaits pour les mises en page statiques et
                    pr√©cises.</li>
                <li style="margin-left: 30px;">‚úÖ Ils offrent plus de flexibilit√© que LazyVGrid, notamment gr√¢ce au
                    col-spanning et aux cellules vides.</li>
                <li style="margin-left: 30px;">‚úÖ Contrairement aux LazyVGrid, ils ne sont pas optimis√©s pour le
                    d√©filement, donc √† √©viter pour afficher de grandes listes d‚Äô√©l√©ments.</li>
            </ul>
        </section>

        <section id="module-8-3" class="module-section">
            <h1 id="container">Cr√©ation de Containers Personnalis√©s avec ViewBuilder en SwiftUI</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/EQe6gZzwzO8" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>


            <h2>Introduction : Pourquoi cr√©er un container personnalis√© ü§î</h2>

            <p>
                Dans SwiftUI, les containers comme VStack, HStack, LazyVGrid et Grid permettent d‚Äôorganiser les vues
                efficacement. Cependant, il arrive que l‚Äôon ait besoin de cr√©er un container sur mesure qui :
            </p>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è Regroupe plusieurs sous-vues de mani√®re personnalis√©e.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Offre une mise en page sp√©cifique qui n‚Äôest pas disponible avec les
                    stacks classiques.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Accepte des sous-vues dynamiques sans que leur nombre soit d√©fini √†
                    l‚Äôavance.</li>
            </ul>

            <p>
                üëâ Pour cela, SwiftUI propose le ViewBuilder, un outil puissant permettant de construire des containers
                personnalis√©s flexibles et r√©utilisables.
            </p>

            <h2>Qu‚Äôest-ce qu‚Äôun ViewBuilder ?</h2>
            <p>
                Un ViewBuilder est un attribut SwiftUI qui permet √† une fonction ou √† une structure d‚Äôaccepter plusieurs
                sous-vues en param√®tre sans n√©cessiter un return explicite.
            </p>
            <h4>üí° Exemple simple :</h4>
            <pre><code class="swift">struct ExempleView: View {
    var body: some View {
        VStack {
            Text("Bonjour")
            Text("Bienvenue sur SwiftUI")
        }
    }
}
</code></pre>

            <p>üìù Ici, SwiftUI interpr√®te automatiquement que VStack contient plusieurs vues sans n√©cessiter de retour
                explicite. </p>
            <p>Le ViewBuilder permet d‚Äôappliquer cette m√™me logique √† nos propres containers.</p>

            <h2>D√©finir un Container Personnalis√© avec ViewBuilder</h2>
            <p>
                Un container personnalis√© est une structure SwiftUI qui prend des sous-vues et les affiche dans une mise
                en page sp√©cifique.
            </p>

            <h4>Syntaxe de base d‚Äôun container personnalis√© avec ViewBuilder</h4>

            <pre><code class="swift">struct CustomContainer< Content: View >: View {
    @ViewBuilder var content: Content // Le param√®tre content peut contenir plusieurs vues

    var body: some View {
        VStack { // On affiche les vues pass√©es en param√®tre
            content
        }
        .padding()
        .background(Color.gray.opacity(0.2))
        .cornerRadius(10)
    }
}
</code></pre>
            <ul>
                <li style="margin-left: 30px;">üîπ <strong>@ViewBuilder var content: Content</strong> : D√©finit un
                    param√®tre capable de recevoir plusieurs sous-vues.</li>
                <li style="margin-left: 30px;">üîπ <strong>Content: View</strong> : Indique que le contenu est une vue
                    SwiftUI.</li>
                <li style="margin-left: 30px;">üîπ <strong>VStack { content }</strong> : Affiche les vues √† l‚Äôint√©rieur
                    d‚Äôun VStack.</li>
            </ul>

            <h2>Utilisation d‚Äôun container personnalis√©</h2>
            <p>
                Maintenant que nous avons notre CustomContainer, nous pouvons l‚Äôutiliser comme n‚Äôimporte quelle vue :
            </p>

            <pre><code class="swift">struct ContentView: View {
    var body: some View {
        CustomContainer {
            Text("Titre")
                .font(.title)
            Text("Ceci est un texte dans un container personnalis√©.")
                .font(.body)
        }
    }
}
</code></pre>

            <p>
                üí° Ici, CustomContainer agit comme un VStack personnalis√©, ajoutant automatiquement du padding, un fond
                gris et des bords arrondis √† son contenu.
            </p>

            <h2>Ajout de param√®tres pour plus de flexibilit√©</h2>
            <p>
                Nous pouvons am√©liorer notre container pour lui permettre de :
            </p>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è Accepter une couleur de fond personnalis√©e.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è D√©finir l‚Äôalignement du texte.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Changer la disposition des vues.</li>
            </ul>

            <h4>Am√©lioration du container personnalis√© :</h4>

            <pre><code class="swift">struct CustomContainer< Content: View >: View {
    var backgroundColor: Color
    var alignment: HorizontalAlignment

    @ViewBuilder var content: Content

    var body: some View {
        VStack(alignment: alignment) {
            content
        }
        .padding()
        .background(backgroundColor)
        .cornerRadius(10)
    }
}
</code></pre>

            <h4>Utilisation avec des param√®tres :</h4>
            <pre><code class="swift">struct ContentView: View {
    var body: some View {
        CustomContainer(backgroundColor: .blue, alignment: .leading) {
            Text("Titre")
                .font(.title)
                .foregroundColor(.white)
            Text("Texte align√© √† gauche dans un container personnalis√©.")
                .font(.body)
                .foregroundColor(.white)
        }
    }
}
</code></pre>

            <p>üìù Ici, nous avons ajout√© deux param√®tres :</p>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è backgroundColor pour changer la couleur du fond.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è alignment pour modifier l‚Äôalignement du texte dans la VStack.</li>
            </ul>

            <h2>Cr√©ation d‚Äôun container personnalis√© avec des animations</h2>
            <p>
                Un container peut aussi contenir des animations pour modifier son apparence en fonction d‚Äôune
                interaction.
            </p>

            <h4>Exemple : Un container qui change de couleur lorsqu‚Äôon clique dessus :</h4>

            <pre><code class="swift">struct AnimatingContainer< Content: View >: View {
    @State private var isTapped = false
    @ViewBuilder var content: Content

    var body: some View {
        VStack {
            content
        }
        .padding()
        .background(isTapped ? Color.red : Color.blue)
        .cornerRadius(10)
        .onTapGesture {
            withAnimation {
                isTapped.toggle()
            }
        }
    }
}
</code></pre>

            <h4>Utilisation du container anim√© :</h4>

            <pre><code class="swift">struct ContentView: View {
    var body: some View {
        AnimatingContainer {
            Text("Cliquez-moi")
                .font(.title)
                .foregroundColor(.white)
        }
    }
}
</code></pre>

            <p>‚úÖ R√©sultat : Chaque fois que l‚Äôutilisateur clique sur le container, la couleur change avec une animation
                fluide.</p>

            <h2>Conclusion</h2>
            <ul>
                <li style="margin-left: 30px;">‚úÖ Le ViewBuilder permet de cr√©er des containers r√©utilisables et
                    personnalis√©s.</li>
                <li style="margin-left: 30px;">‚úÖ On peut ajouter des param√®tres pour contr√¥ler l‚Äôaffichage des
                    sous-vues.</li>
                <li style="margin-left: 30px;">‚úÖ Il est possible d‚Äôajouter des animations et des interactions.</li>
                <li style="margin-left: 30px;">‚úÖ Les containers personnalis√©s am√©liorent la modularit√© et la lisibilit√©
                    du code.</li>
            </ul>
        </section>

        <section id="module-8-4" class="module-section">
            <h1 id="containeravancee">Cr√©ation avanc√©e de containers personnalis√©s en SwiftUI</h1>

            <p>Pour une d√©monstration en vid√©o, regardez la vid√©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/hErDeaD2PT0" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <h2>Rappel : Pourquoi cr√©er un container personnalis√© ?</h2>
            <p>
                Dans SwiftUI, nous avons des containers int√©gr√©s comme VStack, HStack, List et LazyVGrid. Mais parfois,
                nous avons besoin de regrouper et positionner des vues avec une logique personnalis√©e, par exemple :
            </p>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è Une liste de t√¢ches avec des √©l√©ments s√©lectionnables.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Une grille d‚Äô√©l√©ments interactifs avec animation.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Une section d‚Äôinterface avec un en-t√™te personnalis√©.</li>
            </ul>
            <p>
                üí° SwiftUI nous permet de cr√©er nos propres containers en utilisant ViewBuilder.
            </p>

            <h2>Cr√©ation d‚Äôun container personnalis√© avec sections et en-t√™tes</h2>

            <h4>Objectif :</h4>
            <p>
                Nous allons cr√©er un container ‚ÄúCheckList‚Äù qui accepte plusieurs √©l√©ments et les regroupe en sections
                avec en-t√™tes.
            </p>
            <h3>√âtape 1 : Cr√©ation d‚Äôune section d‚Äôen-t√™te</h3>
            <p>Nous cr√©ons d‚Äôabord une vue ChecklistSectionHeader pour afficher un titre avant chaque section.</p>
            <pre><code class="swift">struct ChecklistSectionHeader< Content: View >: View {
    @ViewBuilder var content: Content

    var body: some View {
        HStack {
            content
                .font(.largeTitle)
                .fontWeight(.bold)
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.purple.opacity(0.2))
        .cornerRadius(10)
    }
}
</code></pre>

            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è ChecklistSectionHeader prend une vue en param√®tre et l‚Äôaffiche avec un
                    fond color√©.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Cela permet d‚Äôafficher des en-t√™tes pour diff√©rentes cat√©gories
                    d‚Äô√©l√©ments.</li>
            </ul>

            <h3>√âtape 2 : Cr√©ation du container principal CheckList</h3>
            <p>
                Nous allons maintenant cr√©er le container CheckList, qui :
            </p>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è Accepte plusieurs √©l√©ments en param√®tre.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Affiche chaque section avec son en-t√™te.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Affiche les √©l√©ments sous forme de cases cochables.</li>
            </ul>

            <pre><code class="swift">struct CheckList< Content: View >: View {
    @ViewBuilder var content: Content
    
    var body: some View {
        ScrollView(.vertical) {
            VStack(spacing: 20) {
                ForEach(sections: content) { section in
                    if !section.header.isEmpty {
                        ChecklistSectionHeader { section.header }
                    }
                    ForEach(subviews: section.content) { subview in
                        CheckItemView { subview }
                    }
                }
            }
            .padding()
        }
    }
}
</code></pre>

            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è ForEach(sections: content) : Permet d‚Äôit√©rer sur les sections pass√©es
                    en param√®tre.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Si la section a un en-t√™te, on l‚Äôaffiche gr√¢ce √†
                    ChecklistSectionHeader.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è On affiche ensuite les √©l√©ments de la section avec CheckItemView.</li>
            </ul>
            <h3>√âtape 3 : Cr√©ation d‚Äôun √©l√©ment de liste cochable CheckItemView</h3>

            <p>Les √©l√©ments de la CheckList doivent √™tre interactifs, avec une ic√¥ne de validation qui change
                lorsqu‚Äôon appuie.</p>

            <pre><code class="swift">struct CheckItemView< Content: View >: View {
    @ViewBuilder let content: Content
    
    @State private var isChecked: Bool = false
    
    var body: some View {
        HStack {
            content
                .font(.title)
                .fontWeight(.bold)
            
            Spacer()
            
            Image(systemName: isChecked ? "checkmark.circle.fill" : "circle")
                .foregroundColor(isChecked ? .green : .gray)
                .font(.largeTitle)
                .onTapGesture {
                    withAnimation {
                        isChecked.toggle()
                    }
                }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(radius: 3)
    }
}
</code></pre>

            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è CheckItemView contient un texte + une ic√¥ne de validation.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Lorsque l‚Äôutilisateur clique sur l‚Äôic√¥ne, un @State est mis √† jour
                    et l‚Äôic√¥ne change avec une animation.</li>
            </ul>

            <h3>√âtape 4 : Utilisation du container CheckList</h3>
            <p>Nous pouvons maintenant utiliser CheckList pour afficher une liste d‚Äô√©l√©ments group√©s en sections.
            </p>
            <pre><code class="swift">struct ContentView: View {
    let washerTasks = ["Remplacer le joint", "Tester les suspensions", "Nettoyer le filtre"]
    let dryerTasks = ["Nettoyer le filtre √† charpie", "V√©rifier l‚Äô√©vacuation", "Remplacer les rouleaux"]

    var body: some View {
        CheckList {
            Section("\(Image(systemName: "washer.fill")) Lave-linge") {
                ForEach(washerTasks, id: \.self) { task in
                    Text(task)
                }
            }
            Section("\(Image(systemName: "dryer.fill")) S√®che-linge") {
                ForEach(dryerTasks, id: \.self) { task in
                    Text(task)
                }
            }
        }
    }
}
</code></pre>
            <ul>
                <li style="margin-left: 30px;">‚úîÔ∏è Chaque section a un titre (avec une ic√¥ne).</li>
                <li style="margin-left: 30px;">‚úîÔ∏è Les t√¢ches sont cochables gr√¢ce √† CheckItemView.</li>
                <li style="margin-left: 30px;">‚úîÔ∏è L‚Äôensemble est organis√© en VStack et d√©filable gr√¢ce √† ScrollView.
                </li>
            </ul>

            <h2>R√©sum√© des concepts abord√©s</h2>
            <ul>
                <li style="margin-left: 30px;">‚úÖ Cr√©ation d‚Äôun container CheckList qui accepte plusieurs sous-vues.
                </li>
                <li style="margin-left: 30px;">‚úÖ Gestion des sections avec en-t√™tes personnalis√©s
                    (ChecklistSectionHeader).</li>
                <li style="margin-left: 30px;">‚úÖ Ajout d‚Äôinteraction avec des √©l√©ments s√©lectionnables
                    (CheckItemView).</li>
                <li style="margin-left: 30px;">‚úÖ Utilisation de @State pour modifier les √©l√©ments en fonction des
                    actions utilisateur.</li>
            </ul>
        </section>
    </div>
</body>
</section>
</div>

<footer class="footer">
    <p>D√©velopp√© par <a href="https://github.com/mathrob" style="color: white; text-decoration: underline;">Mathieu
            Robson</a> &copy; <span id="current-year"></span></p>
    <script>
        document.getElementById("current-year").textContent =
            new Date().getFullYear();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</footer>
<div class="back-to-top" id="back-to-top">‚Üë</div>
<script>
    const backToTopButton = document.getElementById("back-to-top");

    window.addEventListener("scroll", () => {
        if (window.scrollY > 300) {
            backToTopButton.style.display = "block";
        } else {
            backToTopButton.style.display = "none";
        }
    });

    backToTopButton.addEventListener("click", () => {
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    });
</script>
</body>

</html>