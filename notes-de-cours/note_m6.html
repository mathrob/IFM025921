<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IFM025921</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" />
    <link rel="stylesheet" href="../style.css" />
</head>

<body>
    <header>
        <h1 style="color: white">Module 6 - Note de cours</h1>
    </header>
    <div class="container">
        <a href="../index.html" class="back-link">â† Retour au module principal</a>

        <section id="module-6-1" class="module-section">
            <h1 id="concurrence">Concurrence et modificateurs d'Ã©vÃ©nements de cycle de vie</h1>

            <p>SwiftUI est un outil puissant qui simplifie la crÃ©ation dâ€™interfaces utilisateur en gÃ©rant
                automatiquement le cycle de vie des vues. Cela signifie que certaines actions, comme la mise Ã  jour de
                lâ€™affichage ou la gestion des donnÃ©es, sont prises en charge sans que vous ayez Ã  vous en soucier.</p>
            <p>Cependant, il arrive que lâ€™on ait besoin de dÃ©clencher certaines actions Ã  des moments prÃ©cis du cycle de
                vie dâ€™une vue. Par exemple :</p>
            <ol>
                <li>ExÃ©cuter un code lorsquâ€™une vue apparaÃ®t Ã  lâ€™Ã©cran.</li>
                <li>Nettoyer des ressources lorsquâ€™une vue disparaÃ®t.</li>
                <li>Lancer une tÃ¢che en arriÃ¨re-plan dÃ¨s que la vue est affichÃ©e.</li>
            </ol>
            <p>Pour cela, SwiftUI propose des modificateurs dâ€™Ã©vÃ©nements, qui permettent dâ€™exÃ©cuter du code en fonction
                de lâ€™Ã©tat de la vue.</p>
            <p>Dans ce chapitre, nous allons voir comment utiliser quatre des modificateurs dâ€™Ã©vÃ©nements les plus
                courants en crÃ©ant un projet qui illustre leur fonctionnement. ğŸš€</p>

            <h2>ğŸ› ï¸ Conception de lâ€™application : CrÃ©ation dâ€™une interface avec des onglets</h2>
            <p>Dans cette section, nous allons apprendre Ã  structurer une application avec une interface utilisant des
                onglets grÃ¢ce Ã  TabView en SwiftUI. Cela permettra Ã  lâ€™utilisateur de naviguer facilement entre
                diffÃ©rentes vues.</p>

            <h3>ğŸ¯ 1. Modification de ContentView.swift</h3>
            <p>Nous allons commencer par modifier le fichier ContentView.swift pour y intÃ©grer une barre dâ€™onglets
                contenant deux vues.</p>

            <p><strong>Ã‰tape 1 :</strong> Ouvrir <code>ContentView.swift</code></p>
            <p>Dans votre projet Xcode, ouvrez <code>ContentView.swift</code>, puis remplacez son contenu par le code
                suivant :</p>

            <pre><code class="swift">
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {
            FirstTabView()
                .tabItem {
                    Image(systemName: "01.circle")
                    Text("Premier")
                }
            
            SecondTabView()
                .tabItem {
                    Image(systemName: "02.circle")
                    Text("DeuxiÃ¨me")
                }
        }
    }
}
</code></pre>

            <p>âœ… Ici, nous utilisons <code>TabView</code> pour afficher deux vues :</p>
            <ol>
                <li><code>FirstTabView()</code> : La premiÃ¨re vue avec une icÃ´ne et un texte â€œPremierâ€.</li>
                <li><code>SecondTabView()</code> : La deuxiÃ¨me vue avec une icÃ´ne et un texte â€œDeuxiÃ¨meâ€.</li>
            </ol>
            <p>Les modificateurs <code>.tabItem</code> permettent dâ€™ajouter une icÃ´ne et un texte pour identifier chaque
                onglet.</p>

            <h3>2. CrÃ©ation des fichiers de vues pour les onglets</h3>

            <p>Nous allons maintenant crÃ©er les fichiers nÃ©cessaires pour ces deux vues.</p>

            <div class="step">
                <p><strong>Ã‰tape 2 :</strong> CrÃ©er la premiÃ¨re vue (<code>FirstTabView</code>)</p>
                <ol>
                    <li>Appuyez sur Cmd + N pour ajouter un nouveau fichier.</li>
                    <li>Dans la fenÃªtre qui sâ€™affiche, sÃ©lectionnez lâ€™onglet iOS, puis choisissez SwiftUI View sous la
                        section â€œInterface utilisateurâ€.</li>
                    <li>Cliquez sur Suivant, nommez le fichier <code>FirstTabView.swift</code>, puis cliquez sur CrÃ©er.
                    </li>
                    <li>Remplacez le contenu du fichier par :</li>
                </ol>
            </div>

            <pre><code class="swift">
import SwiftUI

struct FirstTabView: View {
    var body: some View {
        Text("Vue Un")
            .font(.largeTitle)
            .padding()
    }
}
</code></pre>

            <div class="step">
                <p><strong>Ã‰tape 3 :</strong> CrÃ©er la deuxiÃ¨me vue (<code>SecondTabView</code>)</p>
                <ul>
                    <li>RÃ©pÃ©tez les mÃªmes Ã©tapes que pour <code>FirstTabView</code>, mais cette fois-ci, nommez le
                        fichier <code>SecondTabView.swift</code>.</li>
                    <li>Remplacez son contenu par :</li>
                </ul>
            </div>

            <pre><code class="swift">
import SwiftUI

struct SecondTabView: View {
    var body: some View {
        Text("Vue Deux")
            .font(.largeTitle)
            .padding()
    }
}
</code></pre>

            <h3>ğŸ‰ 3. Test et RÃ©sultat</h3>
            <p>Lancez lâ€™aperÃ§u dans Xcode en cliquant sur Resume ou en exÃ©cutant lâ€™application avec Cmd + R. Vous
                devriez voir une interface avec deux onglets permettant de naviguer entre â€œVue Unâ€ et â€œVue Deuxâ€.</p>

            <img src="../imgs/tabview.png" alt="" style="margin-left: 100px; width: 200px;">

            <h3>ğŸ“Œ RÃ©sumÃ© de ce que nous avons appris :</h3>
            <ul>
                <li>âœ… TabView permet de crÃ©er une navigation par onglets.</li>
                <li>âœ… .tabItem {} ajoute une icÃ´ne et un texte aux onglets.</li>
                <li>âœ… Nous avons sÃ©parÃ© nos vues en fichiers distincts pour une meilleure organisation.</li>
            </ul>

            <br />

            <h2 id="onappear">ğŸ¯ Comprendre les modificateurs onAppear et onDisappear</h2>

            <p>Pour une dÃ©monstration en vidÃ©o, regardez la vidÃ©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/BziQWfInCPc" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <p>SwiftUI nous permet de rÃ©agir aux changements dâ€™affichage des vues grÃ¢ce aux modificateurs
                <code>onAppear()</code> et <code>onDisappear()</code>.
            </p>
            <ul>
                <li style="margin-left: 30px;"><code>onAppear</code> : ExÃ©cute une action lorsque la vue apparaÃ®t Ã 
                    lâ€™Ã©cran.</li>
                <li style="margin-left: 30px;"><code>onDisappear</code> : ExÃ©cute une action lorsque la vue disparaÃ®t de
                    lâ€™Ã©cran.</li>
            </ul>
            <p>Ces modificateurs sont trÃ¨s utiles pour :</p>
            <ul>
                <li style="margin-left: 30px;">âœ… Charger des donnÃ©es quand une vue sâ€™affiche.</li>
                <li style="margin-left: 30px;">âœ… DÃ©marrer une animation ou un effet visuel.</li>
                <li style="margin-left: 30px;">âœ… LibÃ©rer des ressources ou sauvegarder des informations quand une vue
                    disparaÃ®t.</li>
            </ul>

            <h3>ğŸ› ï¸ Ajout des modificateurs onAppear et onDisappear</h3>
            <p>Nous allons maintenant les intÃ©grer dans <code>FirstTabView.swift</code> pour observer leur
                fonctionnement.</p>

            <div class="step">
                <p><strong>Ã‰tape 1 :</strong> Modifier <code>FirstTabView.swift</code></p>
                <p>Ouvrez le fichier <code>FirstTabView.swift</code> et remplacez son contenu par :</p>
            </div>

            <pre><code class="swift">
import SwiftUI

struct FirstTabView: View {
    var body: some View {
        Text("Vue Un")
            .font(.largeTitle)
            .padding()
            .onAppear {
                print("ğŸ”µ FirstTabView est apparu")
            }
            .onDisappear {
                print("ğŸ”´ FirstTabView a disparu")
            }
    }
}
    </code></pre>

            <div class="step">
                <p><strong>Ã‰tape 2 :</strong> Lancer lâ€™application</p>
                <ol>
                    <li>ExÃ©cutez lâ€™application sur un simulateur ou un appareil avec Cmd + R.</li>
                    <li>Ouvrez le panneau Console dans Xcode (View â†’ Debug Area â†’ Activate Console).</li>
                    <li>Observez le message "ğŸ”µ FirstTabView est apparu" qui sâ€™affiche lorsque lâ€™onglet est visible.
                    </li>
                </ol>
            </div>

            <div class="step">
                <p><strong>Ã‰tape 3 :</strong> Changer dâ€™onglet</p>
                <ol>
                    <li>Cliquez sur lâ€™onglet DeuxiÃ¨me pour afficher <code>SecondTabView</code>.</li>
                    <li>Vous verrez apparaÃ®tre le message â€œğŸ”´ FirstTabView a disparuâ€ dans la console.</li>
                    <li>Revenez Ã  lâ€™onglet Premier et notez que â€œğŸ”µ FirstTabView est apparuâ€ est affichÃ© Ã  nouveau.</li>
                </ol>
            </div>

            <h3>ğŸ“Œ Explication du fonctionnement</h3>
            <ol></ol>
            <li style="margin-left: 30px;">Lâ€™application dÃ©marre â†’ <code>FirstTabView</code> est affichÃ© â†’
                <code>onAppear</code> est dÃ©clenchÃ©.
            </li>
            <li style="margin-left: 30px;">Lâ€™utilisateur change dâ€™onglet â†’ <code>FirstTabView</code> disparaÃ®t â†’
                <code>onDisappear</code> est
                dÃ©clenchÃ©.
            </li>
            <li style="margin-left: 30px;">Lâ€™utilisateur revient sur le premier onglet â†’ <code>onAppear</code> est Ã 
                nouveau exÃ©cutÃ©.</li>
            </ol>

            <h4>ğŸš€ Pourquoi câ€™est utile ?</h4>
            <ul>
                <li style="margin-left: 30px;">âœ… Charger des donnÃ©es dynamiquement Ã  lâ€™apparition dâ€™une vue.</li>
                <li style="margin-left: 30px;">âœ… Nettoyer des ressources lorsquâ€™une vue nâ€™est plus visible.</li>
                <li style="margin-left: 30px;">âœ… GÃ©rer des interactions utilisateur en fonction de lâ€™affichage.</li>
            </ul>

            <br />

            <h2 id="onchange">ğŸ¯ Comprendre et utiliser onChange en SwiftUI</h2>
            <p>Le modificateur <code>onChange(of:)</code> permet dâ€™exÃ©cuter une action dÃ¨s quâ€™une valeur spÃ©cifique
                change. Câ€™est particuliÃ¨rement utile lorsque vous souhaitez rÃ©agir aux modifications dâ€™un Ã©tat dans
                votre application.</p>

            <h4>âœ… Quand lâ€™utiliser ?</h4>
            <ol>
                <li>Pour dÃ©tecter les changements dans une variable <code>@State</code> et exÃ©cuter une action en
                    consÃ©quence.</li>
                <li>Pour dÃ©clencher un traitement lorsque lâ€™utilisateur modifie une valeur dans lâ€™interface (ex. champ
                    de texte, sÃ©lection dans une liste, changement dâ€™Ã©tat).</li>
                <li>En conjonction avec la propriÃ©tÃ© dâ€™environnement <code>ScenePhase</code> (utilisÃ©e pour dÃ©tecter si
                    lâ€™application passe en arriÃ¨re-plan ou revient au premier plan).</li>
            </ol>

            <h3>ğŸ› ï¸ Ajout du modificateur onChange</h3>
            <p>Nous allons modifier le fichier <code>SecondTabView.swift</code> pour observer le fonctionnement de
                <code>onChange</code> lorsquâ€™un utilisateur tape dans un champ de texte.
            </p>

            <p>Pour une dÃ©monstration en vidÃ©o, regardez la vidÃ©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/V7X04_gQer0" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <div class="step">
                <p><strong>Ã‰tape 1 :</strong> Modifier <code>SecondTabView.swift</code></p>
                <p>Remplacez le contenu du fichier par le code suivant :</p>
            </div>

            <pre><code class="swift">
import SwiftUI

struct SecondTabView: View {
    @State private var text: String = ""

    var body: some View {
        VStack {
            Text("Tapez quelque chose :")
                .font(.headline)

            TextEditor(text: $text)
                .frame(height: 150)
                .border(Color.gray, width: 1)
                .padding()
                .onChange(of: text) { newValue in
                    print("ğŸ”„ Texte modifiÃ© : \(newValue)")
                }
        }
        .padding()
    }
}

#Preview {
    SecondTabView()
}
    </code></pre>

            <div class="step">
                <p><strong>Ã‰tape 2 :</strong> Lancer lâ€™application</p>
                <ol>
                    <li>ExÃ©cutez lâ€™application dans Xcode avec Cmd + R.</li>
                    <li>Dans le simulateur, tapez du texte dans la zone de saisie.</li>
                </ol>
            </div>

            <div class="step">
                <p><strong>Ã‰tape 3 :</strong> Observer les rÃ©sultats</p>
                <ul>
                    <li>Chaque fois que vous tapez une lettre, la console affiche :
                        <code>ğŸ”„ Texte modifiÃ© : [nouvelle valeur du texte]</code>
                    </li>
                </ul>
            </div>

            <h3>ğŸ“Œ Explication du fonctionnement</h3>
            <ol>
                <li>La variable <code>@State private var text: String = ""</code> est un Ã©tat qui stocke le texte saisi.
                </li>
                <li><code>TextEditor(text: $text)</code> permet Ã  lâ€™utilisateur de modifier cette variable.</li>
                <li>Le modificateur <code>onChange(of: text)</code> surveille <code>text</code> et exÃ©cute du code
                    chaque fois quâ€™il change.</li>
                <li>Ici, on affiche simplement la nouvelle valeur dans la console, mais on pourrait aussi :
                    <ul style="list-style-type: square;">
                        <li style="margin-left: 30px;">Sauvegarder les modifications.</li>
                        <li style="margin-left: 30px;">Mettre Ã  jour une autre partie de lâ€™interface.</li>
                        <li style="margin-left: 30px;">DÃ©clencher une validation de saisie.</li>
                    </ul>
                </li>
            </ol>

            <h3>ğŸš€ Pourquoi onChange est-il utile ?</h3>
            <ul>
                <li style="margin-left: 30px;">âœ… RÃ©agir aux entrÃ©es utilisateur en temps rÃ©el (ex. activer/dÃ©sactiver un
                    bouton en fonction de la
                    saisie).</li>
                <li style="margin-left: 30px;">âœ… DÃ©clencher une mise Ã  jour dynamique (ex. mise Ã  jour dâ€™une liste en
                    fonction dâ€™un filtre).</li>
                <li style="margin-left: 30px;">âœ… Surveiller des changements dâ€™Ã©tat systÃ¨me (ex. vÃ©rifier si
                    lâ€™application passe en arriÃ¨re-plan).
                </li>
            </ul>
        </section>

        <section id="module-6-1" class="module-section">
            <h1 id="observable">Observable et Environment Objects</h1>

            <p>Pour une dÃ©monstration en vidÃ©o, regardez la vidÃ©o suivante :</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/cNqMShcSK5g" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>

            <p>
                Dans ce chapitre, nous allons apprendre Ã  utiliser des objets observables et des objets dâ€™environnement
                dans SwiftUI. Ces objets sont trÃ¨s utiles pour gÃ©rer des donnÃ©es qui changent au cours du temps, comme
                un compteur qui sâ€™incrÃ©mente chaque seconde.
            </p>

            <h2>ğŸ¯ Quâ€™est-ce quâ€™un objet observable?</h2>
            <p>
                Un objet observable est une sorte de â€œboÃ®teâ€ oÃ¹ nous stockons des donnÃ©es que nous voulons suivre
                (observer). DÃ¨s que ces donnÃ©es changent, SwiftUI met Ã  jour automatiquement les vues qui utilisent ces
                donnÃ©es. Par exemple, nous allons crÃ©er un objet qui utilise un Timer pour incrÃ©menter un compteur
                chaque seconde.
            </p>

            <h3>ğŸ› ï¸ CrÃ©ation dâ€™un objet observable</h3>
            <p>
                Commencez par crÃ©er une nouvelle classe pour notre objet observable. Cette classe gÃ©rera un compteur et
                mettra Ã  jour cette valeur chaque seconde Ã  lâ€™aide dâ€™un Timer.
            </p>
            <p>
                Voici Ã  quoi cela pourrait ressembler dans un fichier nommÃ© TimerData.swift :
            </p>
            <pre><code class="swift">
import Foundation

@Observable 
class TimerData {
    var timeCount = 0

    init() {
        // CrÃ©er un timer qui se dÃ©clenche toutes les secondes
        Timer.scheduledTimer(
                    withTimeInterval: 1.0, repeats: true) { _ in
            self.update() // Appel de la fonction update chaque seconde
        }
    }

    // Met Ã  jour le compteur
    func update() {
        timeCount += 1
    }

    // RÃ©initialise le compteur
    func resetCount() {
        timeCount = 0
    }
}
            </code></pre>
            <p>
                Ici, chaque fois que le Timer se dÃ©clenche, il appelle la fonction update() qui incrÃ©mente le compteur.
            </p>

            <h3>ğŸ¯ CrÃ©ation de la vue ContentView</h3>
            <p>
                Maintenant que nous avons notre objet observable, nous allons crÃ©er une vue qui affichera ce compteur.
            </p>
            <ol>
                <li>Ouvrez le fichier <code>ContentView.swift</code>.</li>
                <li>Dans la vue, nous allons afficher le compteur et ajouter un bouton pour le rÃ©initialiser.</li>
            </ol>

            <p>
                Voici comment vous pouvez Ã©crire cette vue :
            </p>
            <pre><code class="swift">
import SwiftUI

struct ContentView: View {

    var timerData: TimerData = TimerData()

    var body: some View {
    
        NavigationStack {
            VStack {
                Text("Compte Ã  rebours = \(timerData.timeCount)")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding()
                
                Button(action: resetCount) {
                    Text("RÃ©initialiser le compteur")
                }
            }
        }
    }

    func resetCount() {
        timerData.resetCount() // Appel pour rÃ©initialiser le compteur
    }
}

#Preview {
    ContentView()
}
            </code></pre>
            <p>
                Quand vous exÃ©cutez cette vue, vous verrez le compteur sâ€™incrÃ©menter chaque seconde, et vous pourrez le
                rÃ©initialiser en appuyant sur le bouton.
            </p>

            <h3>ğŸ¯ Ajout de la DeuxiÃ¨me Vue</h3>
            <p>
                Maintenant, nous allons ajouter une deuxiÃ¨me vue (SecondView) qui affichera Ã©galement le mÃªme compteur.
                Nous voulons nous assurer que la valeur du compteur est partagÃ©e entre les vues.
            </p>
            <ol>
                <li>CrÃ©ez un nouveau fichier SwiftUI pour <code>SecondView.swift</code>.</li>
                <li>Cette vue affichera Ã©galement le compteur, mais elle aura besoin dâ€™accÃ©der au mÃªme objet
                    <strong>TimerData</strong>.</li>
            </ol>

            <p>
                Voici Ã  quoi cela pourrait ressembler :
            </p>
            <pre><code class="swift">
import SwiftUI

struct SecondView: View {

    var timerData: TimerData

    var body: some View {

        VStack {
            Text("DeuxiÃ¨me Vue")
                .font(.largeTitle)
            Text("Compteur de Timer = \(timerData.timeCount)")
                .font(.headline)
        }
        .padding()
    }
}

#AperÃ§u {
    SecondView(timerData: TimerData())
}
            </code></pre>

            <h3>ğŸ¯ Navigation entre les vues</h3>
            <p>
                Pour naviguer de la <strong>ContentView</strong> Ã  la <strong>SecondView</strong>, nous devons ajouter
                un bouton de navigation.
            </p>
            <p>
                Voici comment vous pouvez ajouter un <strong>NavigationLink</strong> dans ContentView pour naviguer vers
                SecondView :
            </p>
            <pre><code class="swift">
var body: some View {
    NavigationStack {
        VStack {
            Text("Compteur de timer = \(timerData.timeCount)")
                .font(.largeTitle)
                .fontWeight(.bold)
                .padding()
            
            Button(action: resetCount) {
                Text("RÃ©initialiser le compteur")
            }
            
            // Lien pour aller Ã  la deuxiÃ¨me vue
            NavigationLink(destination: SecondView(timerData: timerData)) {
                Text("Ã‰cran Suivant")
            }
            .padding()
        }
    }
}
            </code></pre>
            <p>
                Quand vous appuyez sur le bouton â€œÃ‰cran Suivantâ€, lâ€™application va naviguer vers la deuxiÃ¨me vue et
                afficher le mÃªme compteur.
            </p>

            <h3>ğŸ¯ Utilisation dâ€™un Objet dâ€™Environnement</h3>
            <p>
                Au lieu de passer lâ€™objet TimerData manuellement entre les vues, nous allons utiliser un objet
                dâ€™environnement. Cela permet de partager facilement des donnÃ©es entre diffÃ©rentes vues sans avoir Ã  les
                transmettre explicitement.
            </p>

            <ol>
                <li>
                    Modifiez <code>ContentView.swift</code> pour inclure lâ€™objet <strong>TimerData</strong> dans
                    lâ€™environnement :

                    <pre><code class="swift">
import SwiftUI

struct ContentView: View {
    var timerData: TimerData = TimerData()

    var body: some View {
        NavigationStack {
            VStack {
                NavigationLink(destination: SecondView()) {
                    Text("Ã‰cran Suivant")
                }
                .padding()
            }
        }
        .environment(timerData) // Ajout de l'objet TimerData Ã  l'environnement
    }
}

#Preview {
    ContentView()
}
                        </code></pre>
                </li>
                <li>
                    Ensuite, dans SecondView.swift, utilisez le modificateur @Environment pour accÃ©der Ã  lâ€™objet
                    TimerData :
                    <pre><code class="swift">
import SwiftUI

struct SecondView: View {
    @Environment(TimerData.self) var timerData // AccÃ¨s Ã  l'objet TimerData via l'environnement

    var body: some View {
        VStack {
            Text("DeuxiÃ¨me Vue")
                .font(.largeTitle)
            Text("Compteur de Timer = \(timerData.timeCount)")
                .font(.headline)
        }
        .padding()
    }
}

#Preview {
    SecondView()
}
                        </code></pre>
                    <p>Maintenant, les deux vues utilisent le mÃªme objet TimerData grÃ¢ce Ã  lâ€™environnement. Il nâ€™est
                        plus nÃ©cessaire de le passer manuellement dâ€™une vue Ã  lâ€™autre.</p>
                </li>
            </ol>
            <h3>RÃ©sumÃ©</h3>
            <p>
                Dans ce chapitre, vous avez appris Ã  :
            </p>
            <ol>
                <li>âœ… CrÃ©er un objet observable pour suivre des donnÃ©es qui changent, comme un compteur.</li>
                <li>âœ… Utiliser un objet dâ€™environnement pour partager des donnÃ©es entre plusieurs vues sans avoir Ã  les
                    passer manuellement.</li>
                <li>âœ… CrÃ©er des vues interactives qui utilisent ces objets pour afficher et mettre Ã  jour les donnÃ©es
                    dynamiques.</li>
            </ol>
            <p>
                Cela vous permet de crÃ©er des applications plus flexibles et plus simples Ã  maintenir, car vous pouvez
                partager des donnÃ©es entre diffÃ©rentes parties de lâ€™application sans avoir Ã  vous soucier de leur
                transmission manuelle.
            </p>
        </section>
    </div>
</body>
</section>
</div>

<footer class="footer">
    <p>DÃ©veloppÃ© par <a href="https://github.com/mathrob" style="color: white; text-decoration: underline;">Mathieu
            Robson</a> &copy; <span id="current-year"></span></p>
    <script>
        document.getElementById("current-year").textContent =
            new Date().getFullYear();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</footer>
<div class="back-to-top" id="back-to-top">â†‘</div>
<script>
    const backToTopButton = document.getElementById("back-to-top");

    window.addEventListener("scroll", () => {
        if (window.scrollY > 300) {
            backToTopButton.style.display = "block";
        } else {
            backToTopButton.style.display = "none";
        }
    });

    backToTopButton.addEventListener("click", () => {
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    });
</script>
</body>

</html>